<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>测试 CI 自动构建</title>
      <link href="/2019/02/07/test-ci/"/>
      <content type="html"><![CDATA[<blockquote><p>这篇文章由 CI 工具自动构建</p></blockquote>]]></content>
      
      
    </entry>
    
    <entry>
      <title>文档就绪事件（`document ready`）的兼容问题</title>
      <link href="/2019/02/05/ready/"/>
      <content type="html"><![CDATA[<h4 id="文档就绪事件（document-ready）的兼容问题"><a href="#文档就绪事件（document-ready）的兼容问题" class="headerlink" title="文档就绪事件（document ready）的兼容问题"></a>文档就绪事件（<code>document ready</code>）的兼容问题</h4><p>ready 我们称为“就绪”事件。<br>在<strong>W3C DOM</strong>兼容浏览器里面是用DOMContentLoaded实现的，这个在《高程》里面曾经提及过。</p><p>ready事件是在整个<code>DOM</code>文档加载完成以后触发的，表明，现在可以遍历<code>DOM</code>文档了。</p><p><strong>但是在跨浏览器中，使用这个事件的时候，避免不了需要再做一次支持旧版本IE（IE9以前的版本）的工作</strong></p><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="技巧1"><a href="#技巧1" class="headerlink" title="技巧1"></a>技巧1</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>使用<a href="http://javascript.nwbox.com/IEContentLoaded" target="_blank" rel="noopener">Diego Perini创建的一种方法</a>，</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>尝试将文档滚动到最左边（自然位置）。该尝试会一直继续，一直失败，一直到<code>DOM</code>加载完成以后，才停止，<br>所以如果我们不断尝试执行该操作（使用定时器，确保不阻止事件循环），在操作成功时，我们就会知道，<code>DOM</code>已经就绪（ready）了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">The IEContentLoaded source code</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * IEContentLoaded.js</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Author: Diego Perini (diego.perini at gmail.com) NWBOX S.r.l.</span></span><br><span class="line"><span class="comment"> * Summary: DOMContentLoaded emulation for IE browsers</span></span><br><span class="line"><span class="comment"> * Updated: 05/10/2007</span></span><br><span class="line"><span class="comment"> * License: GPL</span></span><br><span class="line"><span class="comment"> * Version: TBD</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2007 Diego Perini &amp; NWBOX S.r.l.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This program is free software: you can redistribute it and/or modify</span></span><br><span class="line"><span class="comment"> * it under the terms of the GNU General Public License as published by</span></span><br><span class="line"><span class="comment"> * the Free Software Foundation, either version 2 of the License, or</span></span><br><span class="line"><span class="comment"> * (at your option) any later version.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This program is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="comment"> * GNU General Public License for more details.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You should have received a copy of the GNU General Public License</span></span><br><span class="line"><span class="comment"> * along with this program.  If not, see http://javascript.nwbox.com/IEContentLoaded/GNU_GPL.txt.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @wwindow reference</span></span><br><span class="line"><span class="comment">// @fnfunction reference</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IEContentLoaded</span> (<span class="params">w, fn</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> d = w.document, done = <span class="literal">false</span>,</span><br><span class="line"><span class="comment">// only fire once</span></span><br><span class="line">init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!done) &#123;</span><br><span class="line">done = <span class="literal">true</span>;</span><br><span class="line">fn();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// polling for no errors</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// throws errors until after ondocumentready</span></span><br><span class="line">d.documentElement.doScroll(<span class="string">'left'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">setTimeout(<span class="built_in">arguments</span>.callee, <span class="number">50</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// no errors, fire</span></span><br><span class="line">init();</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// trying to always fire before onload</span></span><br><span class="line">d.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (d.readyState == <span class="string">'complete'</span>) &#123;</span><br><span class="line">d.onreadystatechange = <span class="literal">null</span>;</span><br><span class="line">init();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="技巧二"><a href="#技巧二" class="headerlink" title="技巧二"></a>技巧二</h2><p>在文档上添加监听<code>onreadystatechange</code>(代码如上)文档了。<br>这个事件和<code>doScroll</code>技巧不太一致——Dom就绪时，该事件会一直触发，但是有时候他会触发好长的时间（但是总在load事件之前）/<br>即使有这个弱点，但是，至少确保了在load事件之前发生了一点事情。</p><h2 id="技巧三"><a href="#技巧三" class="headerlink" title="技巧三"></a>技巧三</h2><p>检查<code>document.readyState</code>属性。该属性可在所有的浏览器当中使用，用于记录当时的DOM加载状态，<br>我们需要知道的是，什么时候到了<code>complete</code>状态。<br>在IE浏览器当中，加载用的时间可能很长，<code>readyState</code>有可能过早地报告完成<code>complete</code>状态，这就是为什么我们不能完全依赖他的原因。</p><blockquote><p>更多关于文档状态的资料可以打开MDN文档 ：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState</a></p></blockquote><h2 id="实现跨浏览器的DOM-ready事件"><a href="#实现跨浏览器的DOM-ready事件" class="headerlink" title="实现跨浏览器的DOM ready事件"></a>实现跨浏览器的DOM ready事件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isReady = <span class="literal">false</span>,   <span class="comment">//假设一开始的时候还没就绪</span></span><br><span class="line">        contentLoadedHandler;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ready</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(!ready)&#123;</span><br><span class="line">        triggerEvent(<span class="built_in">document</span>, <span class="string">"ready"</span>);  </span><br><span class="line">        isReady = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果程序已经就绪，直接触发ready函数。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">document</span>.readyState === <span class="string">"complete"</span>) &#123;</span><br><span class="line">      ready();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于W3C浏览器，创建一个DOMContentLoaded事件处理程序，然后再删除自身</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">document</span>.addEventListener)&#123;</span><br><span class="line">      contentLoadedHandler = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>,removeEventlistener(</span><br><span class="line">          <span class="string">"DOMContentLoaded"</span>, contentLoadedHandler,<span class="literal">false</span></span><br><span class="line">        );</span><br><span class="line">        ready();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">document</span>.addEventListener(</span><br><span class="line">        <span class="string">"DOMContentLoaded"</span>, contentLoadedHandler,<span class="literal">false</span></span><br><span class="line">      );  <span class="comment">//将刚刚创建的contentLoadedHandler处理程序绑定到DOMContentLoaded上面</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于IE模型的浏览器，创建一个处理程序，在文档readyState 为complete状态时，删除自身并触发ready处理程序。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">document</span>.attachEvent)&#123;</span><br><span class="line">      contentLoadedHandler = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">document</span>.readyState === <span class="string">"complete"</span>) &#123;</span><br><span class="line">          <span class="built_in">document</span>.detachEvent(</span><br><span class="line">            <span class="string">"onreadystatechange"</span>, contentLoadedHandler</span><br><span class="line">          )；</span><br><span class="line">        ready();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.attachEvent(</span><br><span class="line">      <span class="string">"onreadystatechange"</span>, contentLoadedHandler);</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toplevel = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      toplevel = <span class="built_in">window</span>.frameElemt == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">document</span>.documentElement.doScroll &amp;&amp; toplevel)&#123;</span><br><span class="line">        doScrollCheck();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义滚动检测函数，持续进行滚动。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doScrollCheck</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(isReady)<span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">document</span>.documentElement.doScroll(<span class="string">"left"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        setTimeout(doScrollCheck,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ready();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></the>]]></content>
      
      <categories>
          
          <category> 分享 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ssh连接linux服务器不断开方法</title>
      <link href="/2019/02/05/ssh-broken/"/>
      <content type="html"><![CDATA[<p>最近ssh登录服务器配置一些东西的时候经常会出现<strong>“Write failed: Broken pipe”</strong>或者直接卡死的情况。服务端的系统是ubuntu.，查询了一下相关的资料，原来可以去配置服务端的sshd,或者客户端的ssh。就ok了。<br>另外推荐两个不错的软件：<strong><a href="http://www.howtogeek.com/howto/ubuntu/keep-your-ssh-session-running-when-you-disconnect/" target="_blank" rel="noopener">screen</a></strong> （服务端），<strong><a href="https://github.com/tmux/tmux" target="_blank" rel="noopener">tmux</a></strong> （客户端）</p><p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h2 id="ssh连接linux服务器不断开-“Write-failed-Broken-pipe”的解决方法"><a href="#ssh连接linux服务器不断开-“Write-failed-Broken-pipe”的解决方法" class="headerlink" title="ssh连接linux服务器不断开 “Write failed: Broken pipe”的解决方法"></a>ssh连接linux服务器不断开 “Write failed: Broken pipe”的解决方法</h2><p>最近ssh登录服务器配置一些东西的时候经常会出现<strong>“Write failed: Broken pipe”</strong>或者直接卡死的情况。服务端的系统是ubuntu.，查询了一下相关的资料，原来可以去配置服务端的sshd,或者客户端的ssh。就ok了。</p><h2 id="配置服务器端sshd"><a href="#配置服务器端sshd" class="headerlink" title="配置服务器端sshd"></a>配置服务器端sshd</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#找到</span></span><br><span class="line">/etc/ssh/sshd_config</span><br><span class="line"><span class="comment">#添加</span></span><br><span class="line">ClientAliveInterval  <span class="number">30</span></span><br></pre></td></tr></table></figure><p>这样设置可以使到server端每30s就会向client端发送一个<strong>keep-alive</strong>包, 来<strong>保持连接</strong><br>另外，可以加上下面这一行,指定发送keep-alive包的最大次数<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#,指定发送keep-alive包的最大次数 为60</span></span><br><span class="line">ClientAliveCountMax  <span class="number">60</span></span><br></pre></td></tr></table></figure></p><p>如果发送keep-alive包<strong>次数达到60,</strong> 而客户端还没有反应,则server端的<strong>sshd断开连接</strong><br>这个配置可以让连接保持30*60s == <strong>30分钟</strong>，也就是如果什么都不操作，30分钟后断开连接。</p><h2 id="配置客户端ssh"><a href="#配置客户端ssh" class="headerlink" title="配置客户端ssh"></a>配置客户端ssh</h2><p>如果<strong>没有服务器权限</strong>,可以配置客户端ssh,这样对这个客户端发起的所有会话都会产生效果</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#找到</span></span><br><span class="line">/etc/ssh/ssh_config</span><br><span class="line"><span class="comment">#添加</span></span><br><span class="line">ServerAliveInterval </span><br><span class="line">   ServerAliveCountMax</span><br></pre></td></tr></table></figure><p>此时就是客户端定时向服务器端发送<strong>keep-alive</strong>包。</p><h2 id="配置会话"><a href="#配置会话" class="headerlink" title="配置会话"></a>配置会话</h2><p>当然登录服务次的频率不会很高，只是偶尔登录，可以指定某个特定的会话<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ssh带上 -o 参数就可以以配置文件的参数指定这一次会话</span></span><br><span class="line">ssh -o ServerAliveInterval=<span class="number">30</span>  root@<span class="number">192.168</span>.<span class="number">12.192</span></span><br></pre></td></tr></table></figure></p><h1 id="推荐两款软件"><a href="#推荐两款软件" class="headerlink" title="推荐两款软件"></a>推荐两款软件</h1><h2 id="screen-（服务端）"><a href="#screen-（服务端）" class="headerlink" title="screen （服务端）"></a><strong><a href="http://www.howtogeek.com/howto/ubuntu/keep-your-ssh-session-running-when-you-disconnect/" target="_blank" rel="noopener">screen</a></strong> （服务端）</h2><blockquote><p><strong><a href="http://www.howtogeek.com/howto/ubuntu/keep-your-ssh-session-running-when-you-disconnect/" target="_blank" rel="noopener">screen</a></strong>就像控制台的窗口管理器。它允许您运行多个终端会话，并在它们之间轻松切换.。它也保护您不断开，因为<strong><a href="http://www.howtogeek.com/howto/ubuntu/keep-your-ssh-session-running-when-you-disconnect/" target="_blank" rel="noopener">screen</a></strong> 的session 当你断开时也不会断开连接。</p></blockquote><p>使用前你需要在你的服务器上面安装<strong>screen</strong>，输入下面的命令就可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install screen</span><br></pre></td></tr></table></figure><p>好的，现在你只要在你的server的命令行上面输入<code>screen</code>你就可以获得关于操作’screen’的一下资讯，继续按<code>Enter</code>，你就可以进入normal模式.<br>To disconnect (but leave the session running)<br>当你需要断开连接，但是保持<code>session</code>的时候，你可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按着 Ctrl + A 接着按 Ctrl + D 你就会看到提示 [detached]</span><br></pre></td></tr></table></figure><p>To reconnect to an already running session<br>继续连接已经断开但是还在运行的<code>session</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -r</span><br></pre></td></tr></table></figure><p>重新连接到现有会话，或者如果没有，就创建新会话<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -D -r</span><br></pre></td></tr></table></figure></p><p>在运行的<code>screen session</code>中创建一个新窗口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按着 Ctrl + A 然后接着按 C  就可以进入新的窗口。</span><br></pre></td></tr></table></figure><p>从一个<code>screen</code>窗口切换到另一个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">敲击 Ctrl + A 然后输入 Ctrl + A 。</span><br></pre></td></tr></table></figure></p><p>列出所有的窗口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">敲击 Ctrl + A 接着按 W。</span><br></pre></td></tr></table></figure></p><p>有很多其他的命令，但这些是我最常用的。</p><h2 id="tmux-（客户端）"><a href="#tmux-（客户端）" class="headerlink" title="tmux （客户端）"></a><strong><a href="https://github.com/tmux/tmux" target="_blank" rel="noopener">tmux</a></strong> （客户端）</h2><p>除了使用<strong><a href="http://www.howtogeek.com/howto/ubuntu/keep-your-ssh-session-running-when-you-disconnect/" target="_blank" rel="noopener">screen</a></strong> 以外，你还可以使用<strong><a href="http://www.howtogeek.com/howto/ubuntu/keep-your-ssh-session-running-when-you-disconnect/" target="_blank" rel="noopener">screen</a></strong>的一个竞争者<strong><a href="https://github.com/tmux/tmux" target="_blank" rel="noopener">tmux</a></strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux new-session -s &#123;name&#125;</span><br></pre></td></tr></table></figure><p>该命令创建一个session。以后当你想要连接服务器的时候，你只要：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux a -t &#123;name&#125;</span><br></pre></td></tr></table></figure><h2 id="关于SSH"><a href="#关于SSH" class="headerlink" title="关于SSH"></a>关于SSH</h2><blockquote><p>SSH是Secure Shell的缩写, 是一个应用层的加密网络协议, 它不只可以用于远程登录, 远程命令执行,还可用于数据传输.</p></blockquote><blockquote><p>当然它由ssh Client和ssh Server端组成, 有很多实现, Ubuntu上就默认安装的OpenSSH, Client端叫做ssh, Server端叫做sshd， OpenSSH只用来做远程登录和命令执行。</p></blockquote><blockquote><p>参考资料</p><ul><li><a href="http://www.howtogeek.com/howto/ubuntu/keep-your-ssh-session-running-when-you-disconnect/" target="_blank" rel="noopener">Keep Your SSH Session Running when You Disconnect</a></li><li><a href="http://stackoverflow.com/questions/13228425/write-failed-broken-pipe" target="_blank" rel="noopener">stackoverflow Write failed : broken pipe</a></li></ul></blockquote>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 分享 </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> tmux </tag>
            
            <tag> screen </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>遍历一个对象</title>
      <link href="/2019/02/05/recursion/"/>
      <content type="html"><![CDATA[<blockquote><p>最近总是在看一些很有趣的文章</p></blockquote><p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h2 id="？？？"><a href="#？？？" class="headerlink" title="？？？"></a>？？？</h2><blockquote><p>最近在读Vue的早期源码，发现挺多有趣的事情的，对象往往是一个深层次的结构，对象的某个属性可能仍然是一个对象，这种情况怎么处理？<br>比如说</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let data = &#123;</span><br><span class="line">    user: &#123;</span><br><span class="line">        name: &quot;lizhihang&quot;,</span><br><span class="line">        age: &quot;22&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    address: &#123;</span><br><span class="line">        city: &quot;Guangzhou&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">答案：`递归算法`，也就是下面代码中的walk函数。如果对象的属性仍然是一个对象的话，那么继续new一个Observer，直到到达最底层的属性位置。</span><br></pre></td></tr></table></figure><h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 观察者构造函数</span><br><span class="line">function Observer(data) &#123;</span><br><span class="line">    this.data = data;</span><br><span class="line">    this.walk(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = Observer.prototype;</span><br><span class="line"></span><br><span class="line">// 此函数用于深层次遍历对象的各个属性</span><br><span class="line">// 采用的是递归的思路</span><br><span class="line">// 因为我们要为对象的每一个属性绑定getter和setter</span><br><span class="line">p.walk = function (obj) &#123;</span><br><span class="line">    let val;</span><br><span class="line">    for (let key in obj) &#123;</span><br><span class="line">        // 这里为什么要用hasOwnProperty进行过滤呢？</span><br><span class="line">        // 因为for...in 循环会把对象原型链上的所有可枚举属性都循环出来</span><br><span class="line">        // 而我们想要的仅仅是这个对象本身拥有的属性，所以要这么做。</span><br><span class="line">        if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            val = obj[key];</span><br><span class="line"></span><br><span class="line">            // 这里进行判断，如果还没有遍历到最底层，继续new Observer</span><br><span class="line">            if (typeof val === &apos;object&apos;) &#123;</span><br><span class="line">                new Observer(val);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //do something</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 分享 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Web安全</title>
      <link href="/2019/02/05/safe/"/>
      <content type="html"><![CDATA[<blockquote><p>当今，互联网安全已经上升到国家非常重视的一个层次。作为一个web工程师，要深刻理解web安全的重要性。下面我总结了几种常见的网络攻击以及防御技巧。</p></blockquote><p><img src="http://www.secbox.cn/wp-content/uploads/2015/09/81a4b79a2a0118ea2324621199cffefd.jpg"></p><ul><li>CSRF 攻击</li><li>如何进行 CSRF 防御呢？</li><li>XSS 攻击</li><li>如何防御 XSS 攻击？</li></ul><p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h2 id="CSRF-攻击"><a href="#CSRF-攻击" class="headerlink" title="CSRF 攻击"></a>CSRF 攻击</h2><p>CSRF(<a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" target="_blank" rel="noopener">Cross-site request forgery</a>)</p><blockquote><p>跨站请求伪造，也被称为：one click attack/session riding， 缩写为：CSRF/XSRF<br>CSRF 可以简单理解为：攻击者盗用了你的身份，以你的名义发送恶意请求，容易造成个人隐私泄露以及财产安全。<br><img src="http://www.secbox.cn/wp-content/uploads/2015/09/81a4b79a2a0118ea2324621199cffefd.jpg"></p></blockquote><h4 id="如上图所示：要完成一次-CSRF-攻击，受害者必须完成："><a href="#如上图所示：要完成一次-CSRF-攻击，受害者必须完成：" class="headerlink" title="如上图所示：要完成一次 CSRF 攻击，受害者必须完成："></a>如上图所示：要完成一次 CSRF 攻击，受害者必须完成：</h4><ul><li>登录受信任网站，并在本地生成 cookie</li><li>在不登出 A 的情况下，访问危险网站 B</li></ul><h4 id="举个简单的例子："><a href="#举个简单的例子：" class="headerlink" title="举个简单的例子："></a>举个简单的例子：</h4><p>例如某个交友网站A，它使用GET请求来完成删除好友的操作，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://friend.johannlai.com/deleteFriends?name=all</span><br></pre></td></tr></table></figure></p><p>而某个危险网站B，它的页面中带有一个这样的标签：（<strong>注意src里面的内容</strong>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;http://friend.johannlai.com/deleteFriends?name=all&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="后果"><a href="#后果" class="headerlink" title="后果"></a>后果</h4><p>当你某一天登陆了交友网站A，然后危险网站B又弹出来的时候，恭喜你，你的好友全部被删除了。<br>原因很简单，就是A网站违反了HTTP规范，使用get请求更新资源。</p><p>其实就算是交友网站A 改为<strong>POST</strong>请求，同样是没有效果，危险网站他同样可以做一样的动作。</p><p><strong>可以看出，CSRF 攻击时源于 WEB 的隐式身份验证机制！WEB 的身份验证机制虽然可以保证一个请求是来自某个用户的浏览器，但无法保证该请求是经过用户批准发送的。</strong></p><h2 id="如何进行-CSRF-防御？"><a href="#如何进行-CSRF-防御？" class="headerlink" title="如何进行 CSRF 防御？"></a>如何进行 CSRF 防御？</h2><p>CSRF 防御可以从<code>服务端</code>和<code>客户端</code>两方面着手，防御效果是从服务端着手效果比较好，现在<strong>一般 CSRF 防御都在服务端</strong>进行的。</p><h4 id="主要有以下的方法"><a href="#主要有以下的方法" class="headerlink" title="主要有以下的方法"></a>主要有以下的方法</h4><p>-关键操作只接受 POST 请求<br>-验证码：</p><p><strong>复杂的验证码</strong>有一个好处，就是，机器很难识别，当用户需要提交的数据需要提示用户输入验证码的时候，一般用户都特别注意，从而简单有效地防御了 CSRF 的攻击。</p><p>但是但是但是，这就让我想起了12306啊</p><p>可以看到，但是如果你自啊一个网站作出任何举动都要输入验证码的话会严重影响用户体验，所以验证码一般只出现在特殊操作里面，或者在注册时候使用。</p><p>而且，简单的验证码是非常不安全的，我自己也曾经用python写过识别验证码，准确率还可以！<br><img src="http://o6m29g00l.bkt.clouddn.com/2017-03-05%2011:05:41%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?e=1488686747&token=FoiyICSlYLk7vMOBABvfUhyCNEcXf4UoIyxcg5iE:jmHqXRAqeJQSCxzeHwCEssgGhys" alt="那时候用来训练模型的切出来的单个数字或者字母验证码"></p><ul><li>检测 Referer：<br>常见的互联网页面与页面之间是存在联系的，比如你在 <a href="http://johannlai.com" target="_blank" rel="noopener">我的博客</a>应该找不到通往 <a href="http://www.qq.com" target="_blank" rel="noopener">http://www.qq.com</a> 的链接的，比如你在某论坛留言，那么不管你留言之后重定向到哪里，之前的网址一定保留在新页面中 Referer 属性中。</li></ul><p>通过检查 Referer 的值，我们就可以判断这个请求是合法的还是非法的，但是<strong>问题出在服务器不是任何时候都接受到 Referer 的值</strong>，所以 Referer Check 一般用于监控 CSRF 攻击的发生，而<code>不用来抵御攻击</code>。</p><ul><li><p>Token：目前主流的做法是使用 Token 防御 CSRF 攻击<br>CSRF 攻击要成功的条件在于攻击者能够准确地预测所有的参数从而构造出合法的请求，所以根据不可预测性原则，我们可以对参数进行加密从而防止 CSRF 攻击，可以保存其原有参数不变，另外添加一个参数 Token，其值是随机的，这样攻击者因为不知道 Token 而无法构造出合法的请求进行攻击，所以我们在构造请求时候只需要保证：</p></li><li><p>Token 要足够随机，使攻击者无法准确预测</p></li><li>Token 是一次性的，即每次请求成功后要更新 Token，增加预测难度</li><li>Token 要主要保密性，敏感操作使用 POST，防止 Token 出现在 URL 中</li></ul><h4 id="推荐一个觉得不错-https-jwt-io"><a href="#推荐一个觉得不错-https-jwt-io" class="headerlink" title="推荐一个觉得不错 https://jwt.io/"></a>推荐一个觉得不错 <a href="https://jwt.io/" target="_blank" rel="noopener">https://jwt.io/</a></h4><blockquote><p>JWT.IO allows you to decode, verify and generate JWT.</p></blockquote><p><strong>最后值得注意的是，过滤用户输入的内容不能阻挡 CSRF 攻击，我们需要做的事过滤请求的来源，因为有些请求是合法，有些是非法的，所以 CSRF 防御主要是过滤那些非法伪造的请求来源。</strong></p><h2 id="XSS-攻击"><a href="#XSS-攻击" class="headerlink" title="XSS 攻击"></a><a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener">XSS 攻击</a></h2><p><a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener">XSS</a> 全称为 Cross-site script，（=.= 为什么不是CSS，哦？懂了，因为HTML）跨站脚本攻击，为了和 CSS 层叠样式表区分所以取名为 XSS，是 Web 程序中常见的漏洞。</p><p><code>原理</code>：攻击者向有 XSS 漏洞的网站中输入恶意的 HTML 代码，当其它用户浏览该网站时候，该段 HTML 代码会自动执行，从而达到攻击的目的，如盗取用户的 Cookie，破坏页面结构，重定向到其它网站等。</p><p>例如我在评论里面写下面这句话！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">var i=0;</span><br><span class="line">while(i&lt;5) &#123;</span><br><span class="line">    alert(&apos;我是XSS！！！ T。T&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>这时候如果服务器没有过滤或转义掉这些脚本，作为内容发布到页面上，其他用户访问这个页面的时候就会运行这段脚本。那就遭受XSS了。</p><h2 id="如何防御-XSS-攻击"><a href="#如何防御-XSS-攻击" class="headerlink" title="如何防御 XSS 攻击"></a>如何防御 XSS 攻击</h2><blockquote><p>网站上所有可输入的地方没有对输入内容进行处理的话，都会存在 XSS 漏洞，漏洞的危险取决于攻击代码的威力，攻击代码也不局限于 script，防御 XSS 攻击最简单直接的方法就是过滤用户的输入。</p></blockquote><p>如果不需要用户输入 HTML，可以直接对用户的输入进行 HTML 转义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--bad--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">window.location.href=&quot;http://www.johannlai.com&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>经过转义后就成了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#Good</span><br><span class="line">&amp;lt;script&amp;gt;window.location.href=&amp;quot;http://www.johannlai.com&amp;quot;&amp;lt;/script&amp;gt;</span><br></pre></td></tr></table></figure></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>当我们需要用户输入 HTML 的时候，需要对用户输入的内容做更加小心细致的处理。</p><p>仅仅粗暴地去掉 script 标签是没有用的，任何一个合法 HTML 标签都可以添加 <code>onclick</code> 一类的事件属性来执行 JavaScript。</p><h2 id="SQL-相关网络攻击"><a href="#SQL-相关网络攻击" class="headerlink" title="SQL 相关网络攻击"></a>SQL 相关网络攻击</h2><p>####SQL 注入：<br>利用现有应用程序，将(恶意) 的 <code>SQL</code> 命令注入到后台数据库引擎执行的能力，它可以通过在<code>Web 表单中输入 (恶意) SQL 语句</code>得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行 SQL 语句。</p><h4 id="SQL注入防御"><a href="#SQL注入防御" class="headerlink" title="SQL注入防御"></a>SQL注入防御</h4><ul><li>永远不要信任用户的输入: 对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和双”-“进行转换等。</li><li>永远不要使用动态拼装 SQL（<strong>野生ＰＨＰer特别注意！</strong>），可以使用参数化的 SQL 或者直接使用存储过程进行数据查询存取。</li><li>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。</li><li>不要把机密信息直接存放，加密或者 hash 掉密码和敏感的信息。</li></ul><h2 id="DDOS-攻击"><a href="#DDOS-攻击" class="headerlink" title="DDOS 攻击"></a>DDOS 攻击</h2><p><a href="https://en.wikipedia.org/wiki/Denial-of-service_attack#Distributed_attack" target="_blank" rel="noopener">分布式拒绝服务</a>(DDoS:Distributed Denial of Service)攻击指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DDoS攻击，从而成倍地提高拒绝服务攻击的威力。</p><blockquote><p>在一个项目中，我也曾经处理过DDos的情况，只是这不是黑客的攻击，是朋友公司的活动抽奖网站出现了漏洞，引起了羊毛党的注意，然后，不停地传播链接，瞬间造成了服务的一个<code>分布式DDos攻击</code>，查看log的UA发现大部分都是移动端的设备。马上采取应急预案，启动服务器正忙页面，修复漏洞，加大CPU和带宽，重新上线。要防止这个事情发生，需要做的就是加强review，加强代码上线前的测试，灰度测试。</p></blockquote><h4 id="真正的DDos"><a href="#真正的DDos" class="headerlink" title="真正的DDos"></a>真正的DDos</h4><blockquote><p>DDOS 攻击利用目标系统网络服务功能缺陷或者直接消耗其系统资源，使得该目标系统无法提供正常的服务。</p></blockquote><blockquote><p>相关新闻 <a href="http://tech.ifeng.com/a/20161023/44475515_0.shtml" target="_blank" rel="noopener">史上最严重DDoS攻击：今早大半个美国“断网”</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL优化笔记----慢查询日志</title>
      <link href="/2019/02/05/mysql-slow-query-log/"/>
      <content type="html"><![CDATA[<blockquote><p>之前做过一个项目，会员量才两位就出现了后台查询数据缓慢的情况！我使用慢查询优化进行解决。<br>引言：MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10S以上的语句。默认情况下，Mysql数据库并不启动慢查询日志，需要我们手动来设置这个参数，当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。</p></blockquote><p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h2 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h2><p>引言：MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10S以上的语句。默认情况下，Mysql数据库并不启动慢查询日志，需要我们手动来设置这个参数，当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。</p><h4 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h4><blockquote><p>The slow query log consists of SQL statements that took more than long_query_time seconds to execute and required at least min_examined_row_limit rows to be examined. The minimum and default values of long_query_time are 0 and 10, respectively. The value can be specified to a resolution of microseconds. For logging to a file, times are written including the microseconds part. For logging to tables, only integer times are written; the microseconds part is ignored.</p></blockquote><p>By default, administrative statements are not logged, nor are queries that do not use indexes for lookups. This behavior can be changed usinglog_slow_admin_statements and log_queries_not_using_indexes, as described later.</p><h2 id="慢查询日志相关参数"><a href="#慢查询日志相关参数" class="headerlink" title="慢查询日志相关参数"></a>慢查询日志相关参数</h2><p>MySQL 慢查询的相关参数解释：</p><p><code>slow_query_log</code>    ：是否开启慢查询日志，1表示开启，0表示关闭。</p><p><code>log-slow-queries</code> ：旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log</p><p><code>slow-query-log-file</code>：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log</p><p><code>long_query_time</code> ：慢查询阈值，当查询时间多于设定的阈值时，记录日志。</p><p><code>log_queries_not_using_indexes</code>：未使用索引的查询也被记录到慢查询日志中（可选项）。</p><blockquote><p>Atention: log_output：日志存储方式。log_output=’FILE’表示将日志存入文件，默认值是’FILE’。log_output=’TABLE’表示将日志存入数据库，这样日志信息就会被写入到mysql.slow_log表中。</p></blockquote><p>##慢查询日志配置<br> 正常情况下慢查询优化slow_query_log的值是OFF，表示慢查询日志是关闭的，可以通过set它的值来开启<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables  like '%slow_query_log%';</span><br><span class="line">+<span class="comment">---------------------+----------------------------------------------------+</span></span><br><span class="line">| Variable_name       | Value                                              |</span><br><span class="line">+<span class="comment">---------------------+----------------------------------------------------+</span></span><br><span class="line">| slow_query_log      | OFF                                                |</span><br><span class="line">| slow_query_log_file | /home/johannlai/MysqlData/mysql/DB-Server-slow.log |</span><br><span class="line">+<span class="comment">---------------------+----------------------------------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; <span class="keyword">set</span> <span class="keyword">global</span> slow_query_log=<span class="number">1</span>;</span><br><span class="line">Query OK, 0 rows affected (0.09 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; show variables like '%slow_query_log%';</span><br><span class="line">+<span class="comment">---------------------+----------------------------------------------------+</span></span><br><span class="line">| Variable_name       | Value                                              |</span><br><span class="line">+<span class="comment">---------------------+----------------------------------------------------+</span></span><br><span class="line">| slow_query_log      | ON                                                 |</span><br><span class="line">| slow_query_log_file | /home/johannlai/MysqlData/mysql/DB-Server-slow.log |</span><br><span class="line">+<span class="comment">---------------------+----------------------------------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure></p><p><em>值得注意的是：使用set global slow_query_log=1开启了慢查询日志只对当前数据库生效，<code>如果MySQL重启后则会失效</code>。如果要永久生效，就必须修改配置文件my.cnf（其它系统变量也是如此）</em></p><p>那么现在我们理论上在mysql源码里是判断大于long_query_time，而非大于等于，的查询就会被记录下来。</p><p>下面这里踩了一个大坑！</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'long_query_time%';</span><br><span class="line">+<span class="comment">-----------------+-----------+</span></span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+<span class="comment">-----------------+-----------+</span></span><br><span class="line">| long_query_time | 10.000000 |</span><br><span class="line">+<span class="comment">-----------------+-----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; <span class="keyword">set</span> <span class="keyword">global</span> long_query_time=<span class="number">4</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; show variables like 'long_query_time';</span><br><span class="line">+<span class="comment">-----------------+-----------+</span></span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+<span class="comment">-----------------+-----------+</span></span><br><span class="line">| long_query_time | 10.000000 |</span><br><span class="line">+<span class="comment">-----------------+-----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>我修改了变量long_query_time，但是查询变量long_query_time的值还是10，难道没有修改到呢？注意：使用命令 set global long_query_time=4修改后，需要重新连接或新开一个会话才能看到修改值。</p><p>下面我把<code>long_query_time</code>设置为2<br><code>set global long_query_time=4;</code></p><p>然后测试一下慢查询日志，就会发现下面的信息<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select sleep(3);</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| sleep(3) |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|        0 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">3.00</span> sec)</span><br><span class="line"> </span><br><span class="line">[johann@johann-Inspiron ~]# more /tmp/mysql_slow.log</span><br><span class="line">/usr/sbin/mysqld, <span class="keyword">Version</span>: <span class="number">5.6</span><span class="number">.20</span>-<span class="keyword">enterprise</span>-commercial-<span class="keyword">advanced</span>-<span class="keyword">log</span> (MySQL <span class="keyword">Enterprise</span> <span class="keyword">Server</span> - <span class="keyword">Advanced</span> <span class="keyword">Edition</span> (Commercial)). started <span class="keyword">with</span>:</span><br><span class="line">Tcp port: <span class="number">0</span>  Unix socket: (<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">Time</span>                 <span class="keyword">Id</span> Command    Argument</span><br><span class="line">/usr/sbin/mysqld, <span class="keyword">Version</span>: <span class="number">5.6</span><span class="number">.20</span>-<span class="keyword">enterprise</span>-commercial-<span class="keyword">advanced</span>-<span class="keyword">log</span> (MySQL <span class="keyword">Enterprise</span> <span class="keyword">Server</span> - <span class="keyword">Advanced</span> <span class="keyword">Edition</span> (Commercial)). started <span class="keyword">with</span>:</span><br><span class="line">Tcp port: <span class="number">0</span>  Unix socket: (<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">Time</span>                 <span class="keyword">Id</span> Command    Argument</span><br><span class="line"># <span class="keyword">Time</span>: <span class="number">160616</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">35</span></span><br><span class="line"># <span class="keyword">User</span>@Host: root[root] @ localhost []  <span class="keyword">Id</span>:     <span class="number">5</span></span><br><span class="line"># Query_time: <span class="number">3.002615</span>  Lock_time: <span class="number">0.000000</span> Rows_sent: <span class="number">1</span>  Rows_examined: <span class="number">0</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">timestamp</span>=<span class="number">1466069075</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sleep</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p><h4 id="另外，如果你想查询有多少条慢查询记录，可以使用系统变量。"><a href="#另外，如果你想查询有多少条慢查询记录，可以使用系统变量。" class="headerlink" title="另外，如果你想查询有多少条慢查询记录，可以使用系统变量。"></a>另外，如果你想查询有多少条慢查询记录，可以使用系统变量。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;%Slow_queries%&apos;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Slow_queries  | 2104  |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><h2 id="日志分析工具mysqldumpslow"><a href="#日志分析工具mysqldumpslow" class="headerlink" title="日志分析工具mysqldumpslow"></a>日志分析工具mysqldumpslow</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[johann@johann-Inspiron ~]# mysqldumpslow --help</span><br><span class="line">Usage: mysqldumpslow [ OPTS... ] [ LOGS... ]</span><br><span class="line"> </span><br><span class="line">Parse and summarize the MySQL slow query log. Options are</span><br><span class="line"> </span><br><span class="line">  --verbose    verbose</span><br><span class="line">  --debug      debug</span><br><span class="line">  --help       write this text to standard output</span><br><span class="line"> </span><br><span class="line">  -v           verbose</span><br><span class="line">  -d           debug</span><br><span class="line">  -s ORDER     what to sort by (al, at, ar, c, l, r, t), 'at' is default</span><br><span class="line">                al: average lock time</span><br><span class="line">                ar: average rows sent</span><br><span class="line">                at: average query time</span><br><span class="line">                 c: count</span><br><span class="line">                 l: lock time</span><br><span class="line">                 r: rows sent</span><br><span class="line">                 t: query time  </span><br><span class="line">  -r           reverse the sort order (largest last instead of first)</span><br><span class="line">  -t NUM       just show the top n queries</span><br><span class="line">  -a           don't abstract all numbers to N and strings to 'S'</span><br><span class="line">  -n NUM       abstract numbers with at least n digits within names</span><br><span class="line">  -g PATTERN   grep: only consider stmts that include this string</span><br><span class="line">  -h HOSTNAME  hostname of db server for *-slow.log filename (can be wildcard),</span><br><span class="line">               default is '*', i.e. match all</span><br><span class="line">  -i NAME      name of server instance (if using mysql.server startup script)</span><br><span class="line">  -l           don't subtract lock time from total time</span><br></pre></td></tr></table></figure><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>得到返回记录集<strong>最多</strong>的10个SQL。</p><p><code>mysqldumpslow -s r -t 10 /database/mysql/mysql06_slow.log</code></p><p>得到访问<strong>次数</strong>最多的<strong>10个SQL</strong></p><p><code>mysqldumpslow -s c -t 10 /database/mysql/mysql06_slow.log</code></p><p>得到按照<strong>时间排序</strong>的前10条里面含有左连接的查询语句。</p><p><code>mysqldumpslow -s t -t 10 -g “left join” /database/mysql/mysql06_slow.log</code></p><p>另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现刷屏的情况。</p><p><code>mysqldumpslow -s r -t 20 /mysqldata/mysql/mysql06-slow.log | more</code></p><blockquote><p>参考资料</p><ul><li><a href="https://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html" target="_blank" rel="noopener">MySQL 文档 6.4.5 The Slow Query Log</a></li></ul></blockquote>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 分享 </category>
          
          <category> 笔记 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>localhost----从坑谈起</title>
      <link href="/2019/02/05/localhost/"/>
      <content type="html"><![CDATA[<p>-从坑谈起<br>date: 2017-02-26 1：10：01<br>categories:</p><ul><li>技术</li><li>分享</li><li>笔记<br>tags:</li><li>locahost</li><li>Django</li><li>laravel</li></ul><hr><blockquote><p>在我测试Django启动服务器localhost的服务的时候，神奇的事情发生了！！！</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python3 ./manage.py runserver</span><br><span class="line">...</span><br><span class="line">Starting development server at http://127.0.0.1:8000/</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我记得我也有项目是8000<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">johann@johann-Inspiron $ php artisan serve</span><br><span class="line">Laravel development server started on http://localhost:8000/</span><br></pre></td></tr></table></figure></p><p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h2 id="什么情况！"><a href="#什么情况！" class="headerlink" title="什么情况！"></a>什么情况！</h2><blockquote><p>在我测试Django启动服务器localhost的服务的时候，神奇的事情发生了！！！</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python3 ./manage.py runserver</span><br><span class="line">...</span><br><span class="line">Starting development server at http://127.0.0.1:8000/</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我记得我也有项目是8000<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">johann@johann-Inspiron php artisan serve</span><br><span class="line">Laravel development server started on http://localhost:8000/</span><br></pre></td></tr></table></figure></p><p>那么问题就来了！！！<br>我在<code>Nginx</code>上面部署项目的时候，如果是同一个ServerName 上面同一个端口号的话，明明就是会冲突，顿时三观全毁灭</p><p>我在认真看了一下URL！<br>当我打开浏览器输入<code>127.0.0.1:8000</code>的时候，启动的是Django的项目！</p><p>那到底<code>Laravel</code>的项目到哪里去了！<br>我没猜错，打开：<code>localhost:8000</code>的时候，是Laravel的信息！</p><p>好奇心爆炸！<br><code>localhost != 127.0.0.1 ！！？？？</code><br><img src="http://img.hb.aicdn.com/a0dfafe3aedfc9a66c31bea114f40cebc60572a31f63-swnUx5_fw658"></p><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><p>这个时候，我想起了<strong>计算机网络</strong>中一个常用的命令<code>netstat</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -apn | grep 8000</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp        0      0 127.0.0.1:8000          0.0.0.0:*               LISTEN      5374/python3</span><br><span class="line">tcp6       0      0 ::1:8000                :::*                    LISTEN      5518/php7.0</span><br></pre></td></tr></table></figure><p>认真看了一下，的确listen的是8000端口，可是，这时候精彩的事情就发生了，地址没发生冲突，</p><blockquote><p>原因是django项目默认是用<strong>ipv4</strong>的127.0.0.1地址，laravel项目默认用的是<strong>ipv6</strong>地址::1，地址不一样，那么端口相同也可以！</p></blockquote><p>这个时候，我又想到一种很科学的研究方法！——<strong>控制变量法</strong></p><p>我想关了两个项目，然后单独打开<strong>Laravel</strong></p><p>发现必须使用下面的地址访问！</p><ul><li><a href="http://localhost:8000/" target="_blank" rel="noopener">http://localhost:8000/</a></li><li>http://[::1]:8000/    /<em>ipv6</em>/</li></ul><p><strong>不可以通过127.0.0.1</strong>访问！</p><p>我马上打开 <code>WIKI</code> ，浏览了一下<a href="https://en.wikipedia.org/wiki/Localhost" target="_blank" rel="noopener">localhost</a>的解释，reason如下：<br>操作系统的<code>hosts</code>文件中的<code>localhost</code>解析一些ip：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1    localhost</span><br><span class="line">::1          localhost</span><br></pre></td></tr></table></figure></p><p>看到这里，突然发现<code>Laravel</code>这一点做得真的是实在太机智了，它考虑到我们有可能存在其他的框架会占用8000端口，然后采用了默认利用ipv6地址，从而避免启动端口冲突问题。</p><p>再查询了一下laravel的文档，在<code>Laravel</code>中，可以这样设置    端口映射。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">johann@johann-Inspiron $ php artisan serve --host=127.0.0.1</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 分享 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> locahost </tag>
            
            <tag> Django </tag>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript学习笔记----浅谈Ajax</title>
      <link href="/2019/02/05/mysql-%E8%BF%9C%E7%A8%8Blogin/"/>
      <content type="html"><![CDATA[<blockquote><p>引言：作为一名合格的web开发者，时刻保持了解工具的内部原理是非常重要的，这对于我们使用工具发明工具非常有用。</p></blockquote><p>Ajax - “asynchronous(异步的) JavaScript and XML”<br>是一种可以在不刷新页面的基础上从服务器上面获取数据的技术。它使用浏览器为内嵌的 XMLHttpRequest (XHR)  去服务器请求数据并且处理服务器返回的数据。</p><p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h2 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h2><p>作为一名合格的web开发者，时刻保持了解工具的内部原理是非常重要的，这对于我们使用工具发明工具非常有用。</p><h4 id="Ajax-“asynchronous-异步的-JavaScript-and-XML”"><a href="#Ajax-“asynchronous-异步的-JavaScript-and-XML”" class="headerlink" title="Ajax - “asynchronous(异步的) JavaScript and XML”"></a>Ajax - “asynchronous(异步的) JavaScript and XML”</h4><p>是一种可以在不刷新页面的基础上从服务器上面获取数据的技术。它使用浏览器为内嵌的 <strong>XMLHttpRequest (XHR)</strong>  去服务器请求数据并且处理服务器返回的数据。</p><h4 id="Ajax"><a href="#Ajax" class="headerlink" title="$.Ajax"></a>$.Ajax</h4><p>我们可以在下面两种场景使用$jQuery的<code>$.ajax()</code>方法。<br>我们可以使用配置对象作为他的唯一的参数，我们也可以传递一个URL和可选的配置作为他的参数</p><h4 id="第一种方法："><a href="#第一种方法：" class="headerlink" title="第一种方法："></a>第一种方法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个当ajax成功的时候会调用的回调函数</span></span><br><span class="line"><span class="keyword">var</span> updatePage = <span class="function"><span class="keyword">function</span>(<span class="params"> resp </span>) </span>&#123;</span><br><span class="line">  $( <span class="string">'#target'</span>).html( resp.people[<span class="number">0</span>].name );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个当ajax失败的时候会调用的回调函数</span></span><br><span class="line"><span class="keyword">var</span> printError = <span class="function"><span class="keyword">function</span>(<span class="params"> req, status, err </span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'something went wrong'</span>, status, err );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个描述ajax请求的对象</span></span><br><span class="line"><span class="keyword">var</span> ajaxOptions = &#123;</span><br><span class="line">  url: <span class="string">'/data/people.json'</span>,</span><br><span class="line">  dataType: <span class="string">'json'</span>,</span><br><span class="line">  success: updatePage,</span><br><span class="line">  error: printError</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发起请求!</span></span><br><span class="line">$.ajax(ajaxOptions);</span><br></pre></td></tr></table></figure><p>当然，你也可以只传递一个<code>$.ajax</code>对象，和使用<code>success</code> 和<code>fail</code>回调。</p><h4 id="下面的这种方法更加容易维护："><a href="#下面的这种方法更加容易维护：" class="headerlink" title="下面的这种方法更加容易维护："></a>下面的这种方法更加容易维护：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: &apos;/data/people.json&apos;,</span><br><span class="line">  dataType: &apos;json&apos;,</span><br><span class="line">  success: function( resp ) &#123;</span><br><span class="line">  $( &apos;#target&apos;).html( resp.people[0].name );</span><br><span class="line">  &#125;,</span><br><span class="line">  error: function( req, status, err ) &#123;</span><br><span class="line">  console.log( &apos;something went wrong&apos;, status, err );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="正如前面提到的-如果你想使用默认配置-ajax-或者如果你想使用相同的配置几个url。你也可以通过一个URL和一个可选的配置对象调用-ajax-方法"><a href="#正如前面提到的-如果你想使用默认配置-ajax-或者如果你想使用相同的配置几个url。你也可以通过一个URL和一个可选的配置对象调用-ajax-方法" class="headerlink" title="正如前面提到的,如果你想使用默认配置 $.ajax() ,或者如果你想使用相同的配置几个url。你也可以通过一个URL和一个可选的配置对象调用 $.ajax() 方法"></a>正如前面提到的,如果你想使用默认配置 <code>$.ajax()</code> ,或者如果你想使用相同的配置几个url。你也可以通过一个URL和一个可选的配置对象调用 <code>$.ajax()</code> 方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.ajax( <span class="string">'/data/people.json'</span>, &#123;</span><br><span class="line">  type: <span class="string">'GET'</span>,</span><br><span class="line">  dataType: <span class="string">'json'</span>,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params"> resp </span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( resp.people );</span><br><span class="line">  &#125;,</span><br><span class="line">  error: <span class="function"><span class="keyword">function</span>(<span class="params"> req, status, err </span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'something went wrong'</span>, status, err );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="原生JavaScript写法"><a href="#原生JavaScript写法" class="headerlink" title="原生JavaScript写法"></a>原生JavaScript写法</h2><p>这个函数是为了创建一个跨浏览器兼容的 <code>XHR</code> 对象.对于 <code>IE 浏览器</code>,所使用的是 <code>ActiveXObject</code> 函数来创建 XHR 对象.<br>而对于其他浏览器则直接使用 <code>XMLHttpRequest API</code> 来创建 XHR 对象.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function createXHR()&#123;</span><br><span class="line">    if(typeof XMLHttpRequest != &apos;undefinded&apos;) &#123;</span><br><span class="line"></span><br><span class="line">        return new XMLHttpRequest();</span><br><span class="line">    &#125; else if(typeof ActiveXObject != &apos;undefined&apos;) &#123;</span><br><span class="line"></span><br><span class="line">        if(typeof argument.callee.activeXString != &apos;string&apos;) &#123; //函数形参</span><br><span class="line"></span><br><span class="line">            var versions = [&apos;MSXML2.XMLHttp&apos;, &apos;MSXML2.XMLHttp.2.0&apos;, &apos;MSXML2.XMLHttp.3.0&apos;, &apos;MSXML2.XMLHttp.4.0&apos;, &apos;MSXML2.XMLHttp.5.0&apos;, &apos;MSXML2.XMLHttp.6.0&apos;];</span><br><span class="line"></span><br><span class="line">            for(var i = 0; i &lt; versions.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    new ActiveXObject(versions[i]);</span><br><span class="line">                    argument.callee.activeXString = versions[i]; //用于告知与创建 ActiveXOPbject 对象版本</span><br><span class="line">                    break;</span><br><span class="line">                &#125; catch(ex)&#123;</span><br><span class="line">                    //pass</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new ActiveXObject(argument.callee.activeXString);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        alert(&apos;Your bowers is not support XHR!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="使用-AJAX-请求数据"><a href="#使用-AJAX-请求数据" class="headerlink" title="使用 AJAX 请求数据"></a>使用 <code>AJAX</code> 请求数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var xhr = createXHR();</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = function()&#123;</span><br><span class="line"></span><br><span class="line">    if(xhr.readyState == 4) &#123;</span><br><span class="line">        if(xhr.status == 200) &#123;</span><br><span class="line">            var data = xhr.responseText;// xhr.responseXML</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.open(&apos;get&apos;, &apos;http://johannlai.com&apos;, true);  //只是预处理连接,并没有实际建立连接或发送请求</span><br><span class="line">//xhr.setRequestHeader(&apos;Content-type&apos;, &apos;text/plain&apos;);  //设置请求头部</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure><h4 id="发送POST请求："><a href="#发送POST请求：" class="headerlink" title="发送POST请求："></a>发送POST请求：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xhr.post = function(url, data, callback, async)&#123;</span><br><span class="line">    var queue = [];</span><br><span class="line">    for(var key in data) &#123;</span><br><span class="line"></span><br><span class="line">        queue.push(encodeURLComponent(key) + &apos;=&apos; + encodeURLComponent(data[key]));</span><br><span class="line">    &#125;</span><br><span class="line">    //注意与 GET 请求的区别</span><br><span class="line">    xhr.send(&apos;GET&apos;, url, queue.join(&apos;&amp;&apos;), callback, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送-GET-请求"><a href="#发送-GET-请求" class="headerlink" title="发送 GET 请求:"></a>发送 GET 请求:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xhr.get = function(url, data, callback, async)&#123;</span><br><span class="line">    var queue = [];</span><br><span class="line">    for(var key in data) &#123;</span><br><span class="line"></span><br><span class="line">         queue.push(encodeURLComponent(key) + &apos;=&apos; + encodeURLComponent(data[key]));</span><br><span class="line">    &#125;</span><br><span class="line">    //注意 GET 请求中的数据放在 URI 中(查询字符串, &apos;?&apos; 后面的数据)</span><br><span class="line">     xhr.send(&apos;GET&apos;, url + (queue.length ? &apos;?&apos; + queue.join(&apos;&amp;&apos;) : &apos;&apos;) , null, callback, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跨域问题-CORS"><a href="#跨域问题-CORS" class="headerlink" title="跨域问题 CORS"></a>跨域问题 CORS</h2><p>跨域问题一直是 Web 开发的一个难题,涉及了 <strong>Web 安全</strong>,浏览器内核等方面的知识,如果只是一直使用像 <code>Jquery</code> 这样的<br>工具库而不去了解它的内部原理的话,那么遇到浏览器的报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest cannot load http://api.johannlai.com. Origin http://localhost:8080 is not allowed by Access-Control-Allow-Origin.</span><br></pre></td></tr></table></figure></p><p>显然会一头雾水，但是如果我们理解了他的内部原理，我们可以很容易的找到解决方法！</p><h2 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h2><p>跨域问题是因为浏览器出于安全考虑采取同源策略,所谓同源策略就是 同协议,同域名,同端口, 如果请求的资源的<br>URI 不符合这三个规定,请求的资源就无法得到,这就称之为跨域问题(即跨域资源共享问题).<br>在浏览器已经提供了解决这个问题的方案了, 就是在请求头部加上 Origin 字段说明发起请求的域名,而服务端的响应<br>头部加上 <code>Access-Control-Allow-Origin</code> 字段说明允许请求资源的域名,域名不在值中的无法正确请求资源.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Origin: url</span><br><span class="line">Access-Control-Allow-Origin: url</span><br></pre></td></tr></table></figure><p>如果需要正确使用 <code>CORS</code> 的话,需要知道下面的几点,因为 <code>HTTP</code> 请求头部中 <code>Origin</code>, Javascript 并没有权利<br>控制, 而是由浏览器这个用户代理来添加的,想想也知道, 如果 Javascript 有这个权利的话, 跨域问题也就不存在了,<br>浏览器安全也无从谈起.</p><p>如何解决跨域问题</p><h4 id="JSONP："><a href="#JSONP：" class="headerlink" title="JSONP："></a>JSONP：</h4><blockquote><p>原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。</p></blockquote><p>由于同源策略的限制，<code>XMLHttpRequest</code>只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。</p><p>优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。</p><p>JSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">createJs</span>(<span class="params">sUrl</span>)</span>&#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> oScript = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="javascript">        oScript.type = <span class="string">'text/javascript'</span>;</span></span><br><span class="line"><span class="undefined">        oScript.src = sUrl;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(oScript);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    createJs(<span class="string">'jsonp.js'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    box(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="string">'name'</span>: <span class="string">'test'</span></span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">box</span>(<span class="params">json</span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">        alert(json.name);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>服务器端对于CORS的支持，主要就是通过设置<code>Access-Control-Allow-Origin</code>来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。</p><p>例如在nodejs的框架Express中可以这样设置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express=<span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> url=<span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">var</span> app=express();</span><br><span class="line"><span class="keyword">var</span> allowCrossDomain = <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'http://localhost:8080'</span>);</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'GET,PUT,POST,DELETE'</span>);</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type'</span>);</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Credentials'</span>,<span class="string">'true'</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;;</span><br><span class="line">app.use(allowCrossDomain);</span><br></pre></td></tr></table></figure></p><p>Nginx中设置如下（conf）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">  ......</span><br><span class="line">  add_header Access-Control-Allow-Origin  http://localhost:8080; #或者是需要跨域的域名，请勿设置为*，极度不安全！</span><br><span class="line">  add_header Access-Control-Allow-Headers X-Requested-With;</span><br><span class="line">  add_header Access-Control-Allow-Methods GET,POST,OPTIONS;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line">这样就可以实现GET,POST,OPTIONS的跨域请求的支持</span><br><span class="line">也可以 add_header Access-Control-Allow-Origin http://test.johannlai.com; --指定允许的url;</span><br></pre></td></tr></table></figure></p><h4 id="通过修改document-domain来跨子域"><a href="#通过修改document-domain来跨子域" class="headerlink" title="通过修改document.domain来跨子域"></a>通过修改document.domain来跨子域</h4><p>将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域</p><p>主域相同的使用document.domain</p><h4 id="使用window-name来进行跨域"><a href="#使用window-name来进行跨域" class="headerlink" title="使用window.name来进行跨域"></a>使用window.name来进行跨域</h4><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的</p><p>使用HTML5中新引进的window.postMessage方法来跨域传送数据</p><p>还有flash、在服务器上设置代理页面等跨域方式。个人认为window.name的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。</p><h2 id="Ajax可用于无阻塞加载脚本"><a href="#Ajax可用于无阻塞加载脚本" class="headerlink" title="Ajax可用于无阻塞加载脚本"></a>Ajax可用于无阻塞加载脚本</h2><p>最近在阅读《高性能JavaScript》中也提到，XMLHTTPRequest（XHR）可以作为一种无阻塞加载脚本的方法获取脚本并且注入页面当中。</p><p>其实也是ajax，先创建一个XHR对象，然后用它下载JavaScript文件，最后通过创建动态<script>元素将代码注入页面。<br>例子如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">"get"</span>,<span class="string">"http://johannlai.com/example.js"</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyStatue == <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status == <span class="number">304</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">            script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">            script.text = xhr.responseText;</span><br><span class="line">            <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>这种方法的<strong>优点</strong>是，你可以下载JavaScript代码，但是不立即执行，其实也就是一个异步（<strong>asynchronous</strong>）的思想，由于代码在<code>&lt;script&gt;</code>标签之外返回的，因此他的下载后不会自动执行，这使得你可以把脚本的执行推迟到你准备好为止。<br>另外一个优点是，同样的代码在所有主流浏览器当中无一例外都可以<strong>正常工作</strong>！</p><blockquote><p>参考资料</p><ul><li><a href="https://book.douban.com/subject/10546125/">《 JavaScript高级程序设计（第3版） 》[美] Nicholas C. Zakas / 李松峰 / 人民邮电出版社 / 2012</a></li><li><a href="https://book.douban.com/subject/26599677/">高性能JavaScript 》【美】Nicholas C. Zakas（尼古拉斯.泽卡斯） / 丁琛 / 电子工业出版社 / 2015</a></li></ul></blockquote></script></p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 分享 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>同学你该复习正则表达式了</title>
      <link href="/2019/02/05/RegExp/"/>
      <content type="html"><![CDATA[<p>最近写JavaScript和PHP都经常碰到写正则表达式的情况，同学你该复习正则表达式了。</p><p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h2 id="热身"><a href="#热身" class="headerlink" title="热身"></a>热身</h2><p>一个正则表达式的简单题目：<br><strong>驼峰式和连字符式的转换</strong><br>很多人可能会用很丑陋的遍历来解决.</p><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s = &quot;style-sheet-base&quot;;</span><br><span class="line"></span><br><span class="line">var a = s.split(&quot;-&quot;);</span><br><span class="line">var o = a[0];</span><br><span class="line">for(var i=1;i&lt;a.length;i++)&#123;</span><br><span class="line">    o = o + a[i].slice(0,1).toUpperCase() + a[i].slice(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果使用正则表达式其实，代码非常整洁（《代码简洁之道》）</p><h4 id="1-驼峰转连字符"><a href="#1-驼峰转连字符" class="headerlink" title="1.驼峰转连字符:"></a>1.驼峰转连字符:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s = &quot;fooStyleCss&quot;;</span><br><span class="line">s = s.replace(/([A-Z])/g,&quot;-$1&quot;).toLowerCase();</span><br></pre></td></tr></table></figure><h4 id="2-转驼峰"><a href="#2-转驼峰" class="headerlink" title="2.转驼峰"></a>2.转驼峰</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s1 = &quot;foo-style-css&quot;;</span><br><span class="line">s1 = s1.replace(//-(/w)/g, function(all, letter)&#123;</span><br><span class="line">        return letter.toUpperCase();</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure><h2 id="一些常用的正则表达式验证"><a href="#一些常用的正则表达式验证" class="headerlink" title="一些常用的正则表达式验证"></a>一些常用的正则表达式验证</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">整数或者小数：`^[0-9]+\.&#123;0,1&#125;[0-9]&#123;0,2&#125;$`</span><br><span class="line">只能输入数字：`&quot;^[0-9]*$&quot;`。</span><br><span class="line">只能输入n位的数字：`&quot;^\d&#123;n&#125;$&quot;`。</span><br><span class="line">只能输入至少n位的数字：`&quot;^\d&#123;n,&#125;$&quot;`。</span><br><span class="line">只能输入m~n位的数字：`&quot;^\d&#123;m,n&#125;$&quot;`</span><br><span class="line">只能输入零和非零开头的数字：`&quot;^(0|[1-9][0-9]*)$&quot;`。</span><br><span class="line">只能输入有两位小数的正实数：`&quot;^[0-9]+(.[0-9]&#123;2&#125;)?$&quot;`。</span><br><span class="line">只能输入有1~3位小数的正实数：`&quot;^[0-9]+(.[0-9]&#123;1,3&#125;)?$`&quot;。</span><br><span class="line">只能输入非零的正整数：`&quot;^\+?[1-9][0-9]*$&quot;`。</span><br><span class="line">只能输入非零的负整数：`&quot;^\-[1-9][]0-9&quot;*$`。</span><br><span class="line">只能输入长度为3的字符：`&quot;^.&#123;3&#125;$&quot;`。</span><br><span class="line">只能输入由26个英文字母组成的字符串：`&quot;^[A-Za-z]+$&quot;`。</span><br><span class="line">只能输入由26个大写英文字母组成的字符串：`&quot;^[A-Z]+$&quot;`。</span><br><span class="line">只能输入由26个小写英文字母组成的字符串：`&quot;^[a-z]+$&quot;`。</span><br><span class="line">只能输入由数字和26个英文字母组成的字符串：`&quot;^[A-Za-z0-9]+$&quot;`。</span><br><span class="line">只能输入由数字、26个英文字母或者下划线组成的字符串：`&quot;^\w+$&quot;`。</span><br><span class="line">验证用户密码：`&quot;^[a-zA-Z]\w&#123;5,17&#125;$&quot;`  正确格式为：以字母开头，长度在6~18之间，只能包含字符、数字和下划线。</span><br><span class="line">验证是否含有**^%&amp;&apos;,;=?$\&quot;**等字符：`&quot;[^%&amp;&apos;,;=?$\x22]+&quot;`。</span><br><span class="line">只能输入汉字：`&quot;^[\u4e00-\u9fa5]&#123;0,&#125;$&quot;`</span><br><span class="line">验证Email地址：`&quot;^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$&quot;`。</span><br><span class="line">验证InternetURL：`&quot;^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$&quot;`。</span><br><span class="line">验证电话号码：`&quot;^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$&quot;`正确格式为：&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX&quot;。</span><br><span class="line">验证身份证号（15位或18位数字）：`&quot;^\d&#123;15&#125;|\d&#123;18&#125;$`。</span><br><span class="line">验证一年的12个月：`&quot;^(0?[1-9]|1[0-2])$&quot;`正确格式为：&quot;01&quot;～&quot;09&quot;和&quot;1&quot;～&quot;12&quot;。</span><br><span class="line">验证一个月的31天：`&quot;^((0?[1-9])|((1|2)[0-9])|30|31)$&quot;`正确格式为；&quot;01&quot;～&quot;09&quot;和&quot;1&quot;～&quot;31&quot;。 匹配中文字符的正则表达式： [\u4e00-\u9fa5]</span><br><span class="line"></span><br><span class="line">匹配双字节字符(包括汉字在内)：`[^\x00-\xff]`</span><br><span class="line"></span><br><span class="line">应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）</span><br><span class="line">String.prototype.len=function()&#123;return this.replace(/[^\x00-\xff]/g,&quot;aa&quot;).length;&#125;</span><br><span class="line"></span><br><span class="line">匹配空行的正则表达式：`\n[\s| ]*\r`</span><br><span class="line"></span><br><span class="line">匹配html标签的正则表达式：`&lt;(.*)&gt;(.*)&lt;\/(.*)&gt;|&lt;(.*)\/&gt;`</span><br><span class="line"></span><br><span class="line">匹配首尾空格的正则表达式：`(^\s*)|(\s*$)`</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL远程连接ERROR 2003 (HY000):Can&#39;t connect to MySQL server on&#39;XXXXX&#39;(111) 的问题</title>
      <link href="/2019/02/05/ajax/"/>
      <content type="html"><![CDATA[<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><blockquote><p>引言：解决方法：修改云主机上的/etc/mysql/my.cnf 文件，注释掉 bind_address=127.0.0.1。这句ok。</p></blockquote><p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h2 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h2><p>最近在设置MySQL的远程数据库连接，试过很多教程都是提示<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 2003 (HY000):Can't connect to MySQL server on'XXXXX'(111)</span><br></pre></td></tr></table></figure></p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>解决方法：修改云主机上的/etc/mysql/my.cnf 文件，注释掉 bind_address=127.0.0.1。这句ok。</p><h4 id="安全MySQL"><a href="#安全MySQL" class="headerlink" title="安全MySQL"></a>安全MySQL</h4><p>*(保障MySQL安全的14个最佳方法)[<a href="http://netsecurity.51cto.com/art/201311/418159.htm]" target="_blank" rel="noopener">http://netsecurity.51cto.com/art/201311/418159.htm]</a></p>]]></content>
      
      <categories>
          
          <category> 分享 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS学习笔记----水平居中、垂直居中、水平垂直居中方法总结</title>
      <link href="/2019/02/05/css-center/"/>
      <content type="html"><![CDATA[<blockquote><p>“44”年前，我们就把人类送上了月球，但现在我们仍然没有办法在CSS中实现垂直居中！ ——James Anderson</p></blockquote><p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h2 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h2><p>作为一名合格的web开发者，总结是对我们的的成长只关重要的，它不只是我们记录下我们学习过的东西，更重要的是，他体现了我们的思考！</p><h4 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h4><p>在CSS中，对元素的<strong>水平居中</strong>是比较简单的。如果他是一个行内元素，就对他的父级元素应用：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">text-align</span><span class="selector-pseudo">:center</span>;</span><br></pre></td></tr></table></figure></p><h4 id="单行文字的垂直居中："><a href="#单行文字的垂直居中：" class="headerlink" title="单行文字的垂直居中："></a>单行文字的垂直居中：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">line-height:30px;</span><br><span class="line">height:30px;</span><br></pre></td></tr></table></figure><h4 id="让有宽度的div水平居中："><a href="#让有宽度的div水平居中：" class="headerlink" title="让有宽度的div水平居中："></a>让有宽度的div水平居中：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">margin: 0 auto;</span><br><span class="line">width:300px;//必须要有**宽度**，margin:0 auto才能让它居中</span><br></pre></td></tr></table></figure><h4 id="让绝对定位的div垂直居中："><a href="#让绝对定位的div垂直居中：" class="headerlink" title="让绝对定位的div垂直居中："></a>让<em>绝对定位</em>的div垂直居中：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">position:absolute;</span><br><span class="line">top:0;</span><br><span class="line">bottom:0;</span><br><span class="line">margin:auto 0;  /*垂直方向的auto 发挥的作用*/</span><br><span class="line">width:300px;</span><br><span class="line">height:300px;</span><br></pre></td></tr></table></figure><h4 id="同理，让绝对定位的div水平和垂直方向都居中："><a href="#同理，让绝对定位的div水平和垂直方向都居中：" class="headerlink" title="同理，让绝对定位的div水平和垂直方向都居中："></a>同理，让绝对定位的div水平和垂直方向都居中：</h4><p>position:absolute;<br>top:0;<br>left: 0;<br>right:0;<br>bottom:0; /<em> 上下左右都有设置，才能使用下面的auto</em>/<br>margin:auto;<br>width:300px;<br>height:300px;</p><h4 id="未知宽高的容器的水平垂直方向居中："><a href="#未知宽高的容器的水平垂直方向居中：" class="headerlink" title="未知宽高的容器的水平垂直方向居中："></a>未知宽高的容器的水平垂直方向居中：</h4><p>width:300px;<br>height:300px;<br>position:absolute;<br>top:50%;<br>left:50%;<br>transform:translate(-50%,-50%); /*<em>注：transform属性，低版本浏览器不兼容，例如IE8</em>/</p><h4 id="水平垂直居中记得要想到flexbox"><a href="#水平垂直居中记得要想到flexbox" class="headerlink" title="水平垂直居中记得要想到flexbox:"></a>水平垂直居中记得要想到flexbox:</h4><p>css终于有了一种简单的垂直居中的方法！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: center;</span><br><span class="line">  justify-content: center;</span><br><span class="line">&#125;</span><br><span class="line">.container .div&#123;</span><br><span class="line">//whatever</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时<strong>.div无论是否已知宽高</strong>，都能两个方向居中。</p><p>TA的兼容情况如下：<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071003.jpg" alt="http://www.ruanyifeng.com/"></p><h4 id="垂直居中（表格布局法）"><a href="#垂直居中（表格布局法）" class="headerlink" title="垂直居中（表格布局法）"></a>垂直居中（表格布局法）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">  display: table;</span><br><span class="line">&#125;</span><br><span class="line">.container .div&#123;</span><br><span class="line">  display: table-cell;</span><br><span class="line">  vertical-align:middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h4 id="为什么height-line-height就能垂直居中？"><a href="#为什么height-line-height就能垂直居中？" class="headerlink" title="为什么height=line-height就能垂直居中？"></a>为什么height=line-height就能垂直居中？</h4><p>读了<a href="http://www.zhangxinxu.com/" target="_blank" rel="noopener">张鑫旭大神</a>的文章：</p><p>-行高指的是什么？ <strong>行高指的是文本行的基线间的距离。</strong></p><ul><li><p>什么是基线？<strong>基线不是文字的下端沿。是英文字母X的下端沿。</strong></p></li><li><p>文字有顶线，底线，基线和中线，用以确定文字行的位置。</p></li><li><p>什么是行距？ <strong>行高与字体尺寸之间的差。</strong><br>还要理解一个概念 – 行内框     行内元素会生成一个行内框。它无法显示出来，但是又确实存在。<br>   在没有其他因素影响的时候，行内框等于内容区域。</p></li></ul><pre><code>&gt; 设定行高可以增加或者减少行内框的高度，即：将行距的值（行高-字体尺寸）除以2，分别加到内容区域的上下两边。这是理解的关键，也就是内容区域的上面和下面均等增加一个距离。可以在一段文字上进行调试看看，发现增加减小line</code></pre><blockquote><p>height时，文字是整体上下缩进的，而非第一行不动，后面的向上靠拢。<br>网上都是这么说的，把line-height值设置为height一样大小的值可以实现单行文字的垂直居中。这句话确实是正确的，但其实也是有问题的。问题在于height，看我的表述：“把line-height设置为您需要的box的大小可以实现单行文字的垂直居中”，差别在于我把height去掉了，这个height是多余的，您不信您可以自己试试。</p></blockquote><p><strong>此处应该有个大坑</strong><br>让line-height等于height，使文字垂直居中的方法，与字体有关？<br>建议 ：因为行高等于高的居中设置法，对微软雅黑 有问题，所以千万不要 在行高，高度跟字体大小差不多的情况下 设置overflow：hidden。</p><blockquote><p>参考资料</p><ul><li><a href="http://www.zhangxinxu.com/wordpress/2009/11/css%E8%A1%8C%E9%AB%98line-height%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">css行高line-height的一些深入理解及应用</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="noopener">Flex 布局教程：语法篇</a></li></ul></blockquote>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 分享 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 居中 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React 的生命周期的使用场景</title>
      <link href="/2019/02/05/React%20Lifecycle%20Methods/"/>
      <content type="html"><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/2000/1*XcGM-8E_hGl4fpAr9wJIsA.png"></p><p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><p>原文链接： <a href="https://engineering.musefind.com/react-lifecycle-methods-how-and-when-to-use-them-2111a1b692b1" target="_blank" rel="noopener">React Lifecycle Methods- how and when to use them</a><br>作者： Scott DomesFollow  Front-End/Mobile Developer @ MuseFind.<br>翻译： <a href="http://johannlai.com" target="_blank" rel="noopener">johannlai</a></p><p>上面这个图片，就是 <strong>React</strong> 组件的生命周期，从形成 (pre-mounting)到销毁 (unmounting)的过程。</p><p><strong>React</strong> 的优雅之处就在于，它把复杂的 UI 分解成很小的部分。 我们不仅仅可以划分我们的应用，而且我们还可以定制我们每一个组件。</p><p>通过组件的生命周期方法，我们可以控制当UI的每个微小部分渲染，更新，重新渲染，直到完全消失时会发生什么事情。</p><p>让我们开始吧！</p><h2 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h2><p>您的组件将很快就会出现在屏幕上面。这个渲染功能与其所有精美的 JSX 一样，即将被调用。那你想做用她来做什么？</p><p>答案是…  <code>componentWillMount</code> 用处不会太大。</p><p>componentWillMount 所处的生命周期是，没有组件可以玩，所以你不能做任何涉及DOM的事情。（译者：因为还没渲染组件）</p><p>此外，自从您组件的构造函数（ constructor  ）被调用以来，没有任何变化，但是，无论如何，您至少应该可以在<code>componentWillMount</code> 的时候设置组件的默认配置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> calss Sidebar extends Component &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      analyticsOpen: <span class="literal">false</span>,</span><br><span class="line">      requirementsOpen: <span class="literal">false</span>,</span><br><span class="line">      barndInfoOpen: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在您的组件处于默认位置，所以不需要额外的生命周期方法，几乎所有的东西都应该由其余的组件代码来处理。</p><p>例外的是，你需要的是只能在运行时完成的任何设置，说白了也就是连接到外部 API 。举个栗子，如果您的应用程序使用 Firebase ，则需要在应用程序首次挂载（mounting）时进行设置。</p><p>但关键是，这样的配置应该在应用程序的最高级别组件（根组​​件）的进行。 这意味着99％的组件应该不能使用 <code>componentWillMount</code> 。</p><p>您可能会看到有人使用<code>componentWillMount</code>启动 AJAX 调用来加载组件的数据。 <strong>千万不要这样做</strong>，我们马上就会聊到这个。</p><p><strong>接下来，更有用的方法是：</strong><br><strong>最常见的用例：</strong> 您的根组件中的应用程序配置。<br><strong>可以调用setState：</strong>不要。改用默认状态（ default state ）。</p><h2 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h2><p>现在您的组件在那里，挂载了并准备好使用了。接下来你将要进行什么操作 ？</p><p>这里是您加载数据的位置。我会让 <a href="https://twitter.com/tylermcginnis33" target="_blank" rel="noopener">Tyler McGinnis</a> 解释为什么：</p><blockquote><p>You can’t guarantee the AJAX request won’t resolve before the component mounts. If it did, that would mean that you’d be trying to setState on an unmounted component, which not only won’t work, but React will yell at you for. Doing AJAX in componentDidMount will guarantee that there’s a component to update.</p></blockquote><blockquote><p>您不能保证在组件挂载之前，AJAX请求已经 resolve 。如果这样做，那意味着你会尝试在一个未挂载的组件上设置 SetState，这不仅不会起作用，反而 React 会对你大喊大叫。在 componentDidMount 中执行 AJAX 将保证至少有已经渲染的组件需要更新。</p></blockquote><p><code>ComponentDidMount</code> 是一个允许你做很多你平时在没有组件的时候不能做的事情。 下面举几个栗子：</p><ul><li>绘制您刚刚渲染的<canvas>元素</canvas></li><li>从元素集合初始化 masonry 网格布局</li><li>增加事件监听器</li></ul><p>基本上，你可以在这里做任何刚刚因为没有 DOM 而不能做的设置，并且可以获取你所需要的全部数据。</p><p><strong>最常见的用例：</strong> 启动<code>AJAX</code>调用，以加载组件的数据。<br><strong>可以调用setState</strong>：是的。</p><h2 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h2><p>我们的组成部分工作得很好，突然之间，一大堆新的 <code>props</code> 到达了，使到组件处于混乱状态。</p><p>这很有可能是一些由父组件的<code>componentDidMount</code>加载的数据终于到达，并被传递下来。</p><p>在我们的组件对新的 <code>props</code> 进行任何操作之前，将用下一<code>props</code> 作为参数调用<code>componentWillReceiveProps</code>。</p><p>&lt;img alt=”componentWillReceiveProps” src=”<a href="https://cdn-images-1.medium.com/max/800/1*u3rXB0qKor51Qb_R1laPjw.png&quot;" target="_blank" rel="noopener">https://cdn-images-1.medium.com/max/800/1*u3rXB0qKor51Qb_R1laPjw.png&quot;</a></p><p>现在，我们正在处于一个很有趣的地方，我们可以（通过nextProps）访问下一个 <code>props</code> 和（通过this.props）访问我们当前的 <code>props</code> 。</p><p>下面这些是我们在<code>componentWillReceiveProps</code> 中需要做的：</p><ul><li>检查哪些<code>props</code> 会改变（使用componentWillReceiveProps的警告 - 有时它什么也没有改变时被调用; React 只是想做一个检查）</li><li>如果<code>props</code> 会以重要的方式改变 <code>props</code>，就行动。</li></ul><p>下面是一个例子。假设我们在上面提到，我们有一个 <canvas> 元素。假设我们根据 <code>this.props.percent</code> 绘制一个很好的圆形图形。</canvas></p><p><img src="https://cdn-images-1.medium.com/max/800/1*SXFIS2pwJ0znpmBjDUfxCQ.png" alt="看起来很不错"></p><p>当我们收到新的<code>props</code> ，例如百分比发生变化，我们想重新绘制网格。可以参考以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps( nextProp ) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.props.percent !== nextProps.percent) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setUpCirCle(nextProps.percent)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 在初始渲染时不调用 componentWillReceiveProps 。<br>我的意思是在技术上，组件正在接收<code>props</code>，但没有任何旧的<code>props</code>要比较，所以…不算。</p><p>最常见的用例：根据特定的<code>props</code>，更改来触发状态（state）转换。<br>是否可以调用<code>setState</code>: Yes</p><h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h2><p>现在我们的组件越来越紧张了。</p><p>我们有新的<code>props</code>。典型的<code>React</code>教条告诉我们，当一个组件接收到新的<code>props</code>或新的<code>state</code>时，它应该更新。</p><p>但是我们的组件会先征求我们的同意。</p><p>这是我们所需要的 —— <code>shouldComponentUpdate</code>方法，以 <code>nextProps</code> 为第一个参数，<code>nextState</code>是第二个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.props.engagement !== nextProps,engagement</span><br><span class="line">    || nextState.input !== <span class="keyword">this</span>.state.input</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>shouldComponentUpdate应该总是返回一个布尔值 —— 就像这个问题的答案<br>–&gt; “我可以渲染吗？”<br>–&gt; 是的，小组件，你可以去渲染。</p><p>默认情况下它总是返回<code>true</code>。</p><p>如果您担心浪费渲染，那么 shouldComponentUpdate 是您提高性能的好地方。</p><p>我以这种方式写了一篇关于使用shouldComponentUpdate的文章 - 看看：</p><blockquote><p><a href="https://engineering.musefind.com/how-to-benchmark-react-components-the-quick-and-dirty-guide-f595baf1014c" target="_blank" rel="noopener">How to Benchmark React Components: The Quick and Dirty Guide</a></p></blockquote><p>在这篇文章中，我们谈论一个有很多 fields 的表格。他遇到的问题是，当表重新渲染时，每个字段也将重新渲染，速度很慢，效率很低。</p><p><code>ShouldComponentUpdate</code>允许这样操作：只有当所关心的<code>props</code>的改变的时候才更新！</p><blockquote><p>但请记住，如果您设置并忘记它，可能会导致重大问题，因为您的React组件将无法正常更新。所以谨慎使用。</p></blockquote><p><strong>最常见的用例：</strong> 当您的组件 <code>re-render</code> (重新渲染)时，完全控制。<br><strong>是否可以调用<code>setState</code>:</strong>  No</p><h2 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a>componentWillUpdate</h2><p>哇，现在我们允许更新了。”希望我在重新渲染之前先做任何事情?” 我们的组件问。不，我们说。停止打扰我们。</p><p>在整个 MuseFind 代码库中，我们从不使用 componentWillUpdate。在功能上，它基本上与<code>componentWillReceiveProps</code>相同，除非你不允许调用<code>this.setState</code>。</p><p>如果您正在使用<code>shouldComponentUpdate</code> 并且需要在<code>props</code>更改时执行某些操作，那么<code>componentWillUpdate</code>才会很有意义。</p><p><strong>最常见的用例：</strong> 在一个也有shouldComponentUpdate（但不能访问以前的<code>props</code>）的组件上使用而不是<code>componentWillReceiveProps</code>。</p><p><strong>是否可以调用<code>setState</code>:</strong>  No</p><h2 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h2><p>很棒！小组件！</p><p>在这里我们可以和<code>componentDidMount</code>做同样的事情 ： 重新设置我们的 masonry 布局，重绘我们的canvas,等。</p><p>等等 - 我们没有在<code>componentWillReceiveProps</code>中重画我们的<code>canvas</code>吗？</p><p>是的我们没有这样做。原因是：<code>在componentDidUpdate</code> 中，你不知道为什么它更新。</p><p>因此，如果我们的组件接收到的<code>canvas</code>数量超过了与我们的<code>canvas</code>相关的<code>props</code>，我们不希望每次更新时都会浪费时间重绘<code>canvas</code>上面。</p><p>这并不意味着<code>componentDidUpdate</code>没有用。要回到我们的 masonry 布局示例，我们要在DOM自身更新后重新排列网格，所以我们使用<code>componentDidUpdate</code>来完成。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate() &#123;</span><br><span class="line">  <span class="keyword">this</span>.createGrid()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>最常见的用例：</strong>更新DOM以响应<code>prop</code>或<code>state</code>更改。<br><strong>是否可以调用<code>setState</code>:</strong>  Yes</p><h2 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h2><p>几乎结束了~</p><p>你的组件将会消失。也许永远，这很伤心。</p><p>在它离开之前，它仍然会询问你是否有任何最后的请求。</p><p>在这里，您可以取消任何传出的网络请求，或删除与组件关联的所有事件监听器。</p><p>基本上，清理任何只涉及到有关的组件的事情，<br>当它走了，它应该完全消失。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  <span class="built_in">window</span>.removeEventListen(<span class="string">'resize'</span>, <span class="keyword">this</span>,resizeListener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最常见的用例：</strong>清理组件中残留的残留物。<br><strong>是否可以调用<code>setState</code>:</strong>  No</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在理想的世界中，我们不会使用生命周期方法。我们所有的渲染问题都将通过<code>state</code> 和 <code>prop</code>进行控制。</p><p>事实上并不存在一个理想的世界，有时您需要更准确地控制组件更新的方式和时间。</p><p>谨慎使用这些方法，并小心使用。我希望这篇文章有助于阐明什么时候和如何使用生命周期方法。</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React 常见的面试题（在 React 里面，你可以知道也可以不知道的事, 但是你会发现他们确实很有用）</title>
      <link href="/2019/02/05/React-Interview-Questions/"/>
      <content type="html"><![CDATA[<p>根据记录，问这些问题可能不是深入了解他们在使用 React 方面的经验的最佳方式。<br>之所以标题是《 React 常见的面试题》，其实只是想起一个比《在 React 里面，你可以知道也可以不知道的事, 但是你会发现他们确实很有用》要简单明了的标题而已。</p><p><img src="https://tylermcginnis.com/react-interview-questions/react-interview-questions.jpg" alt="React 常见的面试题"></p><p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><p>原文链接：<a href="https://tylermcginnis.com/react-interview-questions/" target="_blank" rel="noopener">React Interview Questions</a></p><p>作者： Tyler.Google Developer Expert and a partner at React Training where we teach React online</p><p>翻译：<a href="http://johannlai.com" target="_blank" rel="noopener">Johann Lai</a></p><h2 id="当你调用-setState-的时候，发生了什么事？"><a href="#当你调用-setState-的时候，发生了什么事？" class="headerlink" title="当你调用 setState 的时候，发生了什么事？"></a>当你调用 <strong>setState</strong> 的时候，发生了什么事？</h2><p>当调用 <code>setState</code> 时，React会做的第一件事情是将传递给 <code>setState</code> 的对象合并到组件的当前状态。这将启动一个称为一致化处理（reconciliation）的过程。一致化处理（reconciliation）的最终目标是以最有效的方式，根据这个新的状态来更新UI。 为此，React将构建一个新的 <code>React</code> 元素树（您可以将其视为 UI 的对象表示）。<br>一旦有了这个树，为了弄清 UI 如何响应新的状态而改变，React 会将这个新树与上一个元素树相比较（<strong>diff</strong>）。   </p><p>（译注：一致化处理（reconciliation）可理解为 React 内部将虚拟 DOM 同步更新到真实 DOM 的过程，包括新旧虚拟 DOM 的比较及计算最小 DOM 操作）</p><p>通过这样， React 将会知道发生的确切变化，并且了解发生什么变化以后，只需在绝对必要的情况下进行更新，即可最小化 UI 的占用空间。</p><hr><h2 id="在-React-当中-Element-和-Component-有何区别？"><a href="#在-React-当中-Element-和-Component-有何区别？" class="headerlink" title="在 React 当中  Element 和  Component 有何区别？"></a>在 React 当中  Element 和  Component 有何区别？</h2><p>简单地说，一个 <strong>React  element</strong> 描述了你想在屏幕上看到什么。换个说法就是，一个 <strong>React  element</strong>  是一些 UI 的对象表示。</p><p>一个 <strong>React Component</strong> 是一个函数或一个类，它可以接受输入并返回一个 <strong>React  element</strong> （通常是通过 JSX ，它被转化成一个 createElement 调用）。</p><p>有关更多信息，请查看 <a href="https://tylermcginnis.com/react-elements-vs-react-components/" target="_blank" rel="noopener">React Elements vs React Components</a></p><hr><h2 id="什么时候在功能组件-Functional-Component-上使用类组件-Class-Component-？"><a href="#什么时候在功能组件-Functional-Component-上使用类组件-Class-Component-？" class="headerlink" title="什么时候在功能组件( Functional Component )上使用类组件( Class Component)？"></a>什么时候在功能组件( Functional Component )上使用类组件( Class Component)？</h2><p>如果您的组件具有状态( state )或生命周期方法，请使用 Class 组件。否则，使用功能组件。</p><hr><h2 id="什么是-React-的-refs-，为什么它们很重要？"><a href="#什么是-React-的-refs-，为什么它们很重要？" class="headerlink" title="什么是 React 的 refs ，为什么它们很重要？"></a>什么是 React 的 refs ，为什么它们很重要？</h2><p><strong>refs</strong> 就像是一个逃生舱口，允许您直接访问DOM元素或组件实例。为了使用它们，您可以向组件添加一个 <strong>ref</strong> 属性，该属性的值是一个回调函数，它将接收底层的 DOM 元素或组件的已挂接实例，作为其第一个参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnControlledForm</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleSubmit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Input Value: "</span>, <span class="keyword">this</span>.input.value)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">'text'</span></span><br><span class="line">          ref=&#123;(input) =&gt; <span class="keyword">this</span>.input = input&#125; /&gt;</span><br><span class="line">        &lt;button type=<span class="string">'submit'</span>&gt;Submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上注意到我们的输入字段有一个 <strong>ref</strong> 属性，其值是一个函数。该函数接收放在实例上实际的 DOM 元素 input，以便在 <em>handleSubmit</em> 函数内部访问它。经常被误解的是，您需要使用类组件才能使用<strong>ref</strong> ，但 <strong>ref</strong> 也可以通过利用 <code>JavaScript</code> 中的<strong>闭包</strong>与 功能组件( functional components )一起使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomForm</span> (<span class="params">&#123;handleSubmit&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> inputElement</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;() =&gt; handleSubmit(inputElement.value)&#125;&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">'text'</span></span><br><span class="line">        ref=&#123;(input) =&gt; inputElement = input&#125; /&gt;</span><br><span class="line">      &lt;button type=<span class="string">'submit'</span>&gt;Submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>form&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="React-中的-keys-是什么，为什么它们很重要？"><a href="#React-中的-keys-是什么，为什么它们很重要？" class="headerlink" title="React 中的 keys 是什么，为什么它们很重要？"></a>React 中的 <strong>keys</strong> 是什么，为什么它们很重要？</h2><p><strong>keys</strong> 是帮助 React 跟踪哪些项目已更改、添加或从列表中删除的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;<span class="keyword">this</span>.state.todoItems.map(<span class="function">(<span class="params">&#123;task, uid&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;li key=&#123;uid&#125;&gt;&#123;task&#125;&lt;/li&gt;</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>每个<strong>keys</strong> 在兄弟元素之间是独一无二的。我们已经谈过几次关于一致化处理（reconciliation）的过程，而且这个一致化处理过程（reconciliation）中的一部分正在执行一个新的元素树与最前一个的差异。<strong>keys</strong> 使处理列表时更加高效，因为 React 可以使用子元素上的 <strong>keys</strong> 快速知道元素是新的还是在比较树时才被移动的。</p><p>而且 <strong>keys</strong> 不仅使这个过程更有效率，而且没有<strong>keys</strong>，React 不知道哪个本地状态对应于移动中的哪个项目。所以当你 map 的时候，不要忽略了 <strong>keys</strong> 。</p><h2 id="看下面的代码-如果您在-下创建了一个-React-元素，的组件定义将如何？"><a href="#看下面的代码-如果您在-下创建了一个-React-元素，的组件定义将如何？" class="headerlink" title="看下面的代码: 如果您在  下创建了一个 React 元素，的组件定义将如何？"></a>看下面的代码: 如果您在 <twitter> 下创建了一个 React 元素，<twitter>的组件定义将如何？</twitter></twitter></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Twitter username=<span class="string">'tylermcginnis33'</span>&gt;</span><br><span class="line">  &#123;(user) =&gt; user === <span class="literal">null</span></span><br><span class="line">    ? &lt;Loading /&gt;</span><br><span class="line">    : &lt;Badge info=&#123;user&#125; /&gt;&#125;</span><br><span class="line">&lt;/Twitter&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, PropTypes &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> fetchUser <span class="keyword">from</span> <span class="string">'twitter'</span></span><br><span class="line"><span class="comment">// fetchUser接收用户名返回 promise</span></span><br><span class="line"><span class="comment">// 当得到 用户的数据的时候 ，返回resolve 状态</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在这里写下你的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你不熟悉渲染回调模式（render callback pattern），这将看起来有点奇怪。在这种模式中，一个组件接收一个函数作为它的 child。注意上面包含在 <twitter>标签内的内容。<em>Twitter</em> 组件的 child 是一个函数，而不是你曾经习以为常的一个组件。 这意味着在实现 <em>Twitter</em> 组件时，我们需要将 <em>props.children</em> 作为一个函数来处理。 </twitter></p><p>以下是我的答案。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, PropTypes &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> fetchUser <span class="keyword">from</span> <span class="string">'twitter'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    user: <span class="literal">null</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    username: PropTypes.string.isRequired,</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    fetchUser(<span class="keyword">this</span>.props.username)</span><br><span class="line">      .then(<span class="function">(<span class="params">user</span>) =&gt;</span> <span class="keyword">this</span>.setState(&#123;user&#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children(<span class="keyword">this</span>.state.user)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>值得注意的是</strong>，正如我上面提到的，我通过调用它并传递给 user 来把 props.children 处理为一个函数。</p><p>这种模式的好处是我们已经将我们的父组件与我们的子组件分离了。父组件管理状态，父组件的消费者可以决定以何种方式将从父级接收的参数应用于他们的 UI。</p><p>为了演示这一点，我们假设在另一个文件中，我们要渲染一个 <em>Profile</em> 而不是一个 <em>Badge,</em>，因为我们使用渲染回调模式，所以我们可以轻松地交换 UI ，而不用改变我们对父（Twitter）组件的实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Twitter username=<span class="string">'tylermcginnis33'</span>&gt;</span><br><span class="line">  &#123;(user) =&gt; user === <span class="literal">null</span></span><br><span class="line">    ? &lt;Loading /&gt;</span><br><span class="line">    : &lt;Profile info=&#123;user&#125; /&gt;&#125;</span><br><span class="line">&lt;/Twitter&gt;</span><br></pre></td></tr></table></figure><h2 id="受控组件-controlled-component-与不受控制的组件-uncontrolled-component-有什么区别？"><a href="#受控组件-controlled-component-与不受控制的组件-uncontrolled-component-有什么区别？" class="headerlink" title="受控组件( controlled component )与不受控制的组件( uncontrolled component )有什么区别？"></a>受控组件( controlled component )与不受控制的组件( uncontrolled component )有什么区别？</h2><p>React 的很大一部分是这样的想法，即组件负责控制和管理自己的状态。</p><p>当我们将 native HTML 表单元素（ input, select, textarea 等）投入到组合中时会发生什么？我们是否应该使用 React 作为“单一的真理来源”，就像我们习惯使用React一样？ 或者我们是否允许表单数据存在 DOM 中，就像我们习惯使用HTML表单元素一样？ 这两个问题是受控（controlled） VS 不受控制（uncontrolled）组件的核心。</p><p><strong>受控</strong>组件是React控制的组件，也是表单数据的唯一真理来源。</p><p>如下所示，<em>username</em> 不存在于 DOM 中，而是以我们的组件状态存在。每当我们想要更新 <em>username</em> 时，我们就像以前一样调用setState。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ControlledForm</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    username: <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">  updateUsername = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      username: e.target.value,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  handleSubmit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">'text'</span></span><br><span class="line">          value=&#123;<span class="keyword">this</span>.state.username&#125;</span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.updateUsername&#125; /&gt;</span><br><span class="line">        &lt;button type=<span class="string">'submit'</span>&gt;Submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不受控制( uncontrolled component )的组件是您的表单数据由 DOM 处理，而不是您的 React 组件。</p><p>我们使用 <strong>refs</strong> 来完成这个。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnControlledForm</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleSubmit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Input Value: "</span>, <span class="keyword">this</span>.input.value)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">'text'</span></span><br><span class="line">          ref=&#123;(input) =&gt; <span class="keyword">this</span>.input = input&#125; /&gt;</span><br><span class="line">        &lt;button type=<span class="string">'submit'</span>&gt;Submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>虽然不受控制的组件通常更容易实现，因为您只需使用引用从DOM获取值，但是通常建议您通过不受控制的组件来支持受控组件。</p><p>主要原因是受控组件<strong>支持即时字段验证</strong>，允许您有条件地禁用/启用按钮，强制输入格式，并且更多的是 『the React way』。</p><h2 id="在哪个生命周期事件中你会发出-AJAX-请求，为什么？"><a href="#在哪个生命周期事件中你会发出-AJAX-请求，为什么？" class="headerlink" title="在哪个生命周期事件中你会发出 AJAX 请求，为什么？"></a>在哪个生命周期事件中你会发出 AJAX 请求，为什么？</h2><p>AJAX 请求应该在 <code>componentDidMount</code> 生命周期事件中。 有几个原因:</p><ul><li><p>Fiber，是下一次实施React的和解算法，将有能力根据需要启动和停止渲染，以获得性能优势。其中一个取舍之一是 <code>componentWillMount</code>，而在其他的生命周期事件中出发 AJAX 请求，将是具有 “非确定性的”。 这意味着 React 可以在需要时感觉到不同的时间开始调用 componentWillMount。这显然是AJAX请求的不好方式。</p></li><li><p>您不能保证在组件挂载之前，AJAX请求已经 resolve。如果这样做，那意味着你会尝试在一个未挂载的组件上设置 SetState，这不仅不会起作用，反而会对你大喊大叫。 在 <code>componentDidMount</code> 中执行 AJAX 将保证至少有一个要更新的组件。</p></li></ul><h2 id="shouldComponentUpdate-应该做什么，为什么它很重要？"><a href="#shouldComponentUpdate-应该做什么，为什么它很重要？" class="headerlink" title="shouldComponentUpdate 应该做什么，为什么它很重要？"></a>shouldComponentUpdate 应该做什么，为什么它很重要？</h2><p>上面我们讨论了 reconciliation ，什么是 React 在 setState 被调用时所做的。在生命周期方法 shouldComponentUpdate 中，允许我们选择退出某些组件（和他们的子组件）的 reconciliation  过程。</p><p>我们为什么要这样做？</p><p>如上所述，“一致化处理（ reconciliation ）的最终目标是以最有效的方式，根据新的状态更新用户界面”。如果我们知道我们的用户界面（UI）的某一部分不会改变，那么没有理由让 React 很麻烦地试图去弄清楚它是否应该渲染。通过从 shouldComponentUpdate 返回 false，React 将假定当前组件及其所有子组件将保持与当前组件相同。</p><h2 id="您如何告诉React-构建（build）生产模式，该做什么？"><a href="#您如何告诉React-构建（build）生产模式，该做什么？" class="headerlink" title="您如何告诉React 构建（build）生产模式，该做什么？"></a>您如何告诉React 构建（build）生产模式，该做什么？</h2><p>通常，您将使用Webpack的 <em>DefinePlugin</em> 方法将 <strong>NODE_ENV</strong> 设置为 production。这将剥离像 propType 验证和额外的警告。除此之外，还有一个好主意，可以减少你的代码，因为React使用 Uglify 的 dead-code 来消除开发代码和注释，这将大大减少你的包的大小。</p><h2 id="为什么要使用-React-Children-map（props-children，（）-gt-）-而不是-props-children-map（（）-gt-）"><a href="#为什么要使用-React-Children-map（props-children，（）-gt-）-而不是-props-children-map（（）-gt-）" class="headerlink" title="为什么要使用 React.Children.map（props.children，（）=&gt;） 而不是 props.children.map（（）=&gt;）"></a>为什么要使用 React.Children.map（props.children，（）=&gt;） 而不是 props.children.map（（）=&gt;）</h2><p>因为不能保证props.children将是一个数组。 </p><p>以此代码为例，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Parent&gt;</span><br><span class="line">  &lt;h1&gt;Welcome.&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Parent&gt;</span><br></pre></td></tr></table></figure></p><p>在父组件内部，如果我们尝试使用 props.children.map 映射孩子，则会抛出错误，因为 props.children 是一个对象，而不是一个数组。</p><p>如果有多个子元素，React 只会使props.children成为一个数组。就像下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Parent&gt;</span><br><span class="line">  &lt;h1&gt;Welcome.&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  &lt;h2&gt;props.children will now be an array&lt;/</span>h2&gt;</span><br><span class="line">&lt;<span class="regexp">/Parent&gt;</span></span><br></pre></td></tr></table></figure><p>这就是为什么你喜欢 <code>React.Children.map</code>，因为它的实现考虑到 <code>props.children</code> 可能是一个数组或一个对象。</p><h2 id="描述事件在React中的处理方式。"><a href="#描述事件在React中的处理方式。" class="headerlink" title="描述事件在React中的处理方式。"></a>描述事件在React中的处理方式。</h2><p>为了解决跨浏览器兼容性问题，您的 React 中的事件处理程序将传递<code>SyntheticEvent</code> 的实例，它是 React 的浏览器本机事件的跨浏览器包装器。</p><p>这些 <code>SyntheticEvent</code> 与您习惯的原生事件具有相同的接口，除了它们在所有浏览器中都兼容。有趣的是，React 实际上并没有将事件附加到子节点本身。React 将使用单个事件监听器监听顶层的所有事件。这对于性能是有好处的，这也意味着在更新DOM时，React 不需要担心跟踪事件监听器。</p><h2 id="createElement-和-cloneElement-有什么区别？"><a href="#createElement-和-cloneElement-有什么区别？" class="headerlink" title="createElement 和 cloneElement 有什么区别？"></a>createElement 和 cloneElement 有什么区别？</h2><p>createElement 是 JSX 被转载到的，是 React 用来创建 React Elements 的内容(一些 UI 的对象表示)cloneElement用于克隆元素并传递新的 props。他们钉住了这两个🙂的命名。</p><h2 id="可以选择性地传递给-setState-的第二个参数是什么，它的目的是什么？"><a href="#可以选择性地传递给-setState-的第二个参数是什么，它的目的是什么？" class="headerlink" title="可以选择性地传递给 setState 的第二个参数是什么，它的目的是什么？"></a>可以选择性地传递给 setState 的第二个参数是什么，它的目的是什么？</h2><p>一个回调函数，当setState结束并<code>re-rendered</code>该组件时将被调用。一些没有说出来的东西是 setState 是<strong>异步</strong>的，这就是为什么它需要一个第二个回调函数。通常最好使用另一个生命周期方法，而不是依赖这个回调函数，但是很高兴知道它存在。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'tylermcginnis33'</span> &#125;,</span><br><span class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'setState has finished and the component has re-rendered.'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="这段代码有什么问题？"><a href="#这段代码有什么问题？" class="headerlink" title="这段代码有什么问题？"></a>这段代码有什么问题？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.setState((prevState, props) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    streak: prevState.streak + props.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>没毛病。但是这种写法很少被使用，并不是众所周知的，就是你也可以传递一个函数给setState，它接收到先前的状态和道具并返回一个新的状态，正如我们在上面所做的那样。它不仅没有什么问题，而且如果您根据以前的状态（state）设置状态，推荐使用这种写法。</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JQuery中的设计模式 ——Observer (观察者)模式</title>
      <link href="/2019/02/05/Observer/"/>
      <content type="html"><![CDATA[<p>近日在了解JavaScript的设计模式，抽取其中的（Observer (观察者)模式）来谈一谈。</p><p>什么是观察者模式<br>观察者模式又叫做发布订阅模式（Public/Subscribe），它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生改变时就会通知所有观察着对象。它是由两类对象组成，主题和观察者，主题负责发布事件，同时观察者通过订阅这些事件来观察该主体，发布者和订阅者是完全解耦的，彼此不知道对方的存在，两者仅仅共享一个自定义事件的名称。</p><p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h2 id="JQuery中的设计模式-——Observer-观察者-模式"><a href="#JQuery中的设计模式-——Observer-观察者-模式" class="headerlink" title="JQuery中的设计模式 ——Observer (观察者)模式"></a>JQuery中的设计模式 ——Observer (观察者)模式</h2><p>近日在了解JavaScript的设计模式，抽取其中的（Observer (观察者)模式）来谈一谈。</p><h2 id="什么是观察者模式"><a href="#什么是观察者模式" class="headerlink" title="什么是观察者模式"></a>什么是观察者模式</h2><blockquote><p>观察者模式又叫做发布订阅模式（<strong>Public/Subscribe</strong>），它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生改变时就会通知所有观察着对象。它是由两类对象组成，主题和观察者，主题负责发布事件，同时观察者通过订阅这些事件来观察该主体，发布者和订阅者是完全解耦的，彼此不知道对方的存在，两者仅仅共享一个自定义事件的名称。</p></blockquote><h2 id="观察者模式的好处："><a href="#观察者模式的好处：" class="headerlink" title="观察者模式的好处："></a>观察者模式的好处：</h2><p>比如一个模块(或者多个模块)订阅了一个主题(或者事件)，另一个模块发布这个主题时候，订阅这个主题模块就可以执行了，观察者主要让订阅者与发布者解耦，发布者不需要知道哪些模块订阅了这个主题，它只管发布这个主题就可以了，同样订阅者也无需知道那个模块会发布这个主题，它只管订阅这个主题就可以了。这样2个模块(或更多模块)就实现了关联了。<br><strong>总的来说：就是多个不同业务模块需要相互关联的时候，可以使用观察者模式。</strong></p><h4 id="在JQuery中"><a href="#在JQuery中" class="headerlink" title="在JQuery中"></a>在JQuery中</h4><p>jQuery核心具有对Public/Subscribe类系统的内置支持，我们称为 <em>自定义事件</em></p><p><strong>jQuery</strong>的自定义事件可以使用下面的方法访问</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jQuery.bind(subscribe)</span><br><span class="line">jQuery.trigger()(publish)</span><br><span class="line">jQuery.unbind(unsubscribe)</span><br><span class="line"><span class="comment">//最新版支持</span></span><br><span class="line">jQuery.on()</span><br><span class="line">jQuery.trigger()</span><br><span class="line">jQuery.off()</span><br></pre></td></tr></table></figure><p>比如如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jQuery.subscribe(“done”,fun2);</span><br><span class="line"></span><br><span class="line">function fun1()&#123;</span><br><span class="line"></span><br><span class="line">jQuery.publish(“done”);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>上面的jQuery.publish(“done”);意思是执行fun1函数后，向信号中心jquery发布done信号，而jquery.subscribe(“done”,fun2)的意思是：绑定done信号，执行fun2函数。</p></blockquote><h2 id="talk-is-cheap-show-me-the-code"><a href="#talk-is-cheap-show-me-the-code" class="headerlink" title="talk is cheap ,show me the code."></a>talk is cheap ,show me the code.</h2><p>看到这里，很多人的冲动就来了，看到一个js库有一些功能，就喜欢用原生去实现一下，下面我们就来实现一下自己的<strong>Pub/Sub模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PubSub</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.handlers = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">PubSub.prototype = &#123;</span><br><span class="line"> <span class="comment">// 订阅事件</span></span><br><span class="line"> on: <span class="function"><span class="keyword">function</span>(<span class="params">eventType,handler</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span>(!(eventType <span class="keyword">in</span> self.handlers)) &#123;</span><br><span class="line">    self.handlers[eventType] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  self.handlers[eventType].push(handler);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 触发事件(发布事件)</span></span><br><span class="line">    emit: <span class="function"><span class="keyword">function</span>(<span class="params">eventType</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">     <span class="keyword">var</span> handlerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; self.handlers[eventType].length; i++) &#123;</span><br><span class="line">     self.handlers[eventType][i].apply(self,handlerArgs);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> self;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 调用方式如下：</span><br><span class="line"></span><br><span class="line">var pubsub = new PubSub();</span><br><span class="line"></span><br><span class="line">pubsub.on(&apos;A&apos;,function(data)&#123;</span><br><span class="line"></span><br><span class="line">console.log(1 + data);  // 执行第一个回调业务函数</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pubsub.on(&apos;A&apos;,function(data)&#123;</span><br><span class="line"></span><br><span class="line">console.log(2 + data); // 执行第二个业务回调函数</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 触发事件A</span><br><span class="line"></span><br><span class="line">pubsub.emit(&apos;A&apos;,&quot;我是参数&quot;);</span><br><span class="line">//1我是参数</span><br><span class="line"></span><br><span class="line">//2我是参数</span><br></pre></td></tr></table></figure><blockquote><p>参考资料</p><ul><li><a href="https://book.douban.com/subject/24744217/" target="_blank" rel="noopener">《JavaScript设计模式 》Addy Osmani / 徐涛 / 人民邮电出版社 / 2013</a></li></ul></blockquote>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 分享 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>(译)学习React之前你应该知道的事</title>
      <link href="/2018/02/22/studyReact/"/>
      <content type="html"><![CDATA[<p>这是学习任何一门技术的坚实基础，不仅仅是React</p><p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><p>原文链接：<a href="http://alves.im/blog/before-dive-into-react.html" target="_blank" rel="noopener">Before dive into React</a><br>作者：Henrique Alves — @healves82<br>翻译：<a href="http://johannlai.com" target="_blank" rel="noopener">johannlai</a></p><h2 id="学习React之前你应该知道的事"><a href="#学习React之前你应该知道的事" class="headerlink" title="学习React之前你应该知道的事"></a>学习React之前你应该知道的事</h2><p>我曾经帮助过几个朋友开始使用React，但是仅仅是在基本功能的层面。他们之前都没有任何前端开发的经验。<br>如果你已经是一个前端工程师，那么，你应该浏览下面这个网站 <a href="https://medium.freecodecamp.com/what-to-learn-in-2017-if-youre-a-frontend-developer-b6cfef46effd?gi=6cc3e93ee1fb#.epqapplk0" target="_blank" rel="noopener">《作为一名前端工程师2017年应该学习什么？》</a></p><h2 id="正确地提问"><a href="#正确地提问" class="headerlink" title="正确地提问"></a>正确地提问</h2><p>如何正确地提问，什么时候提问，还有不应该问什么问题，对于新手学习都是非常重要的。<br>举个栗子，假设你现在不知道如何管理状态（state），然后你会去Google <a href="https://www.google.co.uk/search?q=react+manage+state" target="_blank" rel="noopener">React state management</a>，你可以很容易地搜索到一些关于store和redux的文章，然后使到你头晕脑胀，不知所云。</p><p>然后，和他们（新手）交谈过程中中，我会告诉他:</p><blockquote><p>“停止去搜索，然后去阅读关于一切关于react的内容”</p></blockquote><p>互联网上面充斥着各种杂乱和过时的信息。这些都很容易在错误的地方被终结。例如有些教程会告诉你如何使用<code>Webpack</code>。当然在这里并没有毛病，但是，对于正在搜索state的你，现在并不需要这条搜索结果。</p><blockquote><p>“这里没有捷径，请夯实基础”</p></blockquote><p>有一些问题根本和<code>React</code>无关。他们是经典的<code>JavaScript</code>问题。如果走的捷径，没而没有<code>夯实基础</code>，在开始的时候，你可能并不会发现有什么不妥。但是在个人发展到中期甚至长期的时候，他们将是你的绊脚石，你知道这样写可以实现，但是你不知道为什么会这样。</p><blockquote><p>“不不不，学习React并不需要Redux，React Router， CSS Modules，Webpack， 或者其他东西”</p></blockquote><p>说到这里，我已经要求他们停止目前手头上的正在做的事情，回归基础。</p><h2 id="开始去熟悉"><a href="#开始去熟悉" class="headerlink" title="开始去熟悉"></a>开始去熟悉</h2><p>如果你没有前端开发经验，那么你应该从基础学起，当你熟悉了前端的基础以后，你才能找到你需要学习的方向。</p><blockquote><p>“多关注关键的概念，而不是细节”</p></blockquote><p>Mozilla开发者网站（<a href="https://developer.mozilla.org/en-US/" target="_blank" rel="noopener">MDN</a>，是一个很好的开始学习基础的网站，我平时主要使用它来检索一些关于HTML，CSS，或者JavaScript的文档。</p><h4 id="网站和浏览器"><a href="#网站和浏览器" class="headerlink" title="网站和浏览器"></a>网站和浏览器</h4><ul><li>HTTP 请求</li><li>浏览器渲染 ——<a href="https://developers.google.com/web/fundamentals/performance/rendering/" target="_blank" rel="noopener">the pixel pipeline graph</a></li></ul><h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><ul><li>CSS命名规范 例如<a href="http://getbem.com/naming/" target="_blank" rel="noopener">BEM</a>，<a href="https://suitcss.github.io/" target="_blank" rel="noopener">Suit</a></li><li><a href="http://cssreference.io/" target="_blank" rel="noopener">使用flexbox布局</a></li><li><a href="https://github.com/airbnb/css" target="_blank" rel="noopener">好的练手例子</a></li></ul><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Introduction" target="_blank" rel="noopener">什么是JavaScript</a></li><li><a href="http://speakingjs.com/es5/ch01.html" target="_blank" rel="noopener">JavaScript基础</a></li><li><a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">Airbnb JavaScript Style Guide () { </a></li><li>ES6/ES2015</li></ul><h4 id="Bundlers"><a href="#Bundlers" class="headerlink" title="Bundlers"></a>Bundlers</h4><ul><li><a href="https://medium.com/@gimenete/how-javascript-bundlers-work-1fc0d0caf2da#.n9m1iaol8" target="_blank" rel="noopener">什么是JavaScript bundlers work</a></li><li>Webpack, Browserfy and Rollup</li></ul><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><ul><li><a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a></li><li><a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a> , <a href="https://yarnpkg.com/en/" target="_blank" rel="noopener">yarn</a></li><li><a href="https://developer.chrome.com/devtools" target="_blank" rel="noopener">Chrome DevTools</a></li><li>熟悉基础终端的操作 ls, cp, mv, mkdir, etc</li><li>检查iTerm 和Hyper终端</li><li>使用 JS Bin, WebpackBin or CodePen 构建快速原型</li><li><a href="https://atom.io/" target="_blank" rel="noopener">Atom</a>, <a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Code</a>, <a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">Sublime Text</a></li></ul><h4 id="Git-and-GitHub"><a href="#Git-and-GitHub" class="headerlink" title="Git and GitHub"></a>Git and GitHub</h4><ul><li><a href="https://guides.github.com/introduction/flow/" target="_blank" rel="noopener">理解git工作流</a></li><li>在Github上面创建仓库(repo)</li><li><a href="https://help.github.com/articles/about-pull-requests/" target="_blank" rel="noopener">什么是pull requests</a></li><li>用<code>git clone</code>从Github上面克隆一个项目到你的终端（terminal）</li><li>Pull, commit and push 你做的更改</li></ul><h4 id="组件设计"><a href="#组件设计" class="headerlink" title="组件设计"></a>组件设计</h4><ul><li><a href="http://v3.danielmall.com/articles/researching-design-systems/" target="_blank" rel="noopener">设计系统</a></li><li><a href="http://bradfrost.com/blog/post/atomic-web-design/" target="_blank" rel="noopener">atomic-web-design</a></li><li><a href="http://v3.danielmall.com/articles/content-display-patterns/" target="_blank" rel="noopener">内容和显示模式</a></li><li><a href="https://facebook.github.io/react/docs/thinking-in-react.html" target="_blank" rel="noopener">Thinking in React</a></li></ul><p><code>&quot;不要被这个列表吓倒&quot;</code></p><blockquote><p>“阅读，实践，失败，重来。继续做直到你弄懂为止”</p></blockquote><p><strong>这是学习任何一门技术的坚实基础，不仅仅是React</strong></p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于JavaScript的垃圾回收（GC）机制和循环引用。</title>
      <link href="/2017/03/24/jsMemery/"/>
      <content type="html"><![CDATA[<p>最近查看Mozilla 文档上的例子, 这个是在 IE 6,7 里的,<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">div.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;; <span class="comment">// The div has a reference to the event handler via its 'onclick' property</span></span><br><span class="line"><span class="comment">// The handler also has a reference to the div since the 'div' variable can be accessed within the function scope</span></span><br><span class="line"><span class="comment">// This cycle will cause both objects not to be garbage-collected and thus a memory leak.</span></span><br></pre></td></tr></table></figure></p><p>又是一个关于在IE浏览器上面的内存泄漏的问题。</p><p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><hr><h1 id="关于JavaScript的垃圾回收（GC）机制和循环引用。"><a href="#关于JavaScript的垃圾回收（GC）机制和循环引用。" class="headerlink" title="关于JavaScript的垃圾回收（GC）机制和循环引用。"></a>关于JavaScript的垃圾回收（GC）机制和循环引用。</h1><hr><h2 id="JavaScript的垃圾收集机制"><a href="#JavaScript的垃圾收集机制" class="headerlink" title="JavaScript的垃圾收集机制"></a>JavaScript的垃圾收集机制</h2><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><blockquote><p>到2008年止。 <code>IE</code>，<code>FireFox</code>，<code>Opera</code>，<code>Chrome</code>，<code>Safari</code>的JavaScript实现使用的都是标记清除式的GC机制（或者类似的策略），只是垃圾回收的时间和间隔互不相同。</p></blockquote><p>当变量进入环境时，如在函数中var一个变量，此时将这个变量标记为进入环境，当变量离开环境的时候，则将其标记为离开环境，可以通过翻转某一个位来标记一个变量何时进入了环境。但标记不是重点，重点是标记了之后怎么来将其处理。垃圾收集器会在运行的时候给存储在内存中的所有变量都加上标记，然后，它会去掉环境中的变量以及被环境中的变量应用的标记，在此之后再把加上标记的变量都将被视为准备删除的变量。最后，垃圾收集器完成内存的清楚工作，销毁那些带标记的值并收回它们所占用的内存空间。</p><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>跟踪记录每个值被引用的次数，当这个值的引用次数变成0的时候，说明没有办法再访问这个这个值，就将其占用的内存空间收回来，下次再运行垃圾收集器的时候，就会释放哪些引用次数为0的值所占用的内存了。</p><p>但存在的一个问题是，如果有循环引用，即A有个指针指向B，B也有一个指针指向A，在采用标记清楚策略的实现中，这将是个噩梦。如果DOM元素和原生JS对象之间创建了<code>循环引用</code>，那就带来<code>内存泄露</code>的问题，解决方法是把DOM和BOM对象转换成真正的JS对象。</p><p><img src="http://o6m29g00l.bkt.clouddn.com/2017-03-24%2010:43:12%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><p>看到这里，我不禁想起<code>《Javascript高级程序设计》</code>中提到，<strong>IE 中有一部分对象并不是原生的JavaScript对象</strong>， 例如<strong>BOM*  和 </strong>DOM<strong> 中的对象就是C++的COM（组件对象模型， 他的GC机制就是上文说到的</strong>引用计数**）;</p><p>请看下面的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'someElement'</span>);</span><br><span class="line">  element.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(element.id);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>书上描述“由于匿名函数中引用了element，所以element的引用数最少是1，<strong>导致占用的内存永远不会被回收</strong>。把这个就叫内存泄漏。</p><p>建议写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'someElement'</span>);</span><br><span class="line">  <span class="keyword">var</span> id = element.id;</span><br><span class="line">  element.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(id);</span><br><span class="line">  &#125;;</span><br><span class="line">  element = <span class="literal">null</span>;  <span class="comment">//手工断开原生JavaScript对象与DOM元素之间的连接，**避免循环引用产生的问题**。 当</span></span><br><span class="line">                   <span class="comment">//当下次垃圾收集运行的时候，就会删除这些值并回收他们的内存，</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为了解决这些问题，<strong>IE 9</strong> 已经把BOM和DOM对象都转换成为真正的<strong>JavaScript</strong>对象。这样就避免了两种垃圾收集算法并存导致的问题，也消除了常见的<strong>内存泄露现象</strong></p></blockquote>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nginx debug  错误[emerg] “server” directive is not allowed here</title>
      <link href="/2017/01/09/nginx-test/"/>
      <content type="html"><![CDATA[<p>  最近nginx部署ssl证书的时候，突然出现了</p><pre><code>nginx: [emerg] &quot;server&quot; directive is not allowed here</code></pre><p>   这样的错误，后来发现：</p><blockquote><h4 id="正确的检测修改的Nginx的语法是否错误的命令应该是："><a href="#正确的检测修改的Nginx的语法是否错误的命令应该是：" class="headerlink" title="正确的检测修改的Nginx的语法是否错误的命令应该是："></a>正确的检测修改的Nginx的语法是否错误的命令应该是：</h4><p>sudo nginx -t -c /etc/nginx/nginx.conf</p></blockquote><p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><hr><h1 id="Nginx-Debug错误-emerg-“server”-directive-is-not-allowed-here"><a href="#Nginx-Debug错误-emerg-“server”-directive-is-not-allowed-here" class="headerlink" title="Nginx Debug错误[emerg] “server” directive is not allowed here"></a>Nginx Debug错误[emerg] “server” directive is not allowed here</h1><hr><ul><li><strong>服务器环境</strong> ：ubuntu 14.04, nginx/1.4.6；</li><li><strong>执行命令</strong> ：sudo nginx -t -c /etc/nginx/conf.d/default.conf；</li><li><strong>命令目的</strong> ：重启nginx出错，查看新修改的nginx是否有错误，避免上线导致服务器出错。</li></ul><p>一开始以为是语法错误，仔细检查过，并且使用官方配置文件还是出错</p><p>最后自己根据网上的资料猜测，是我进行语法检测的对象有问题。</p><p>要检测现有的修改过的Nginx配置是否有错误，不是单单检测那个修改过的扩展的 <strong>.conf</strong> 文件。而是不管任何时候，始终都是去检测主文件 <strong>/etc/nginx/nginx.conf</strong> ，只有这样，才能顺利的在对应的模块加载扩展的 .conf 文件。</p><p>这样一来保证了配置的前后语境的正确性，二来，这样才是真正的检测（完全和实际运行情况相符）</p><p>所以正确的检测修改的Nginx的语法是否错误的命令应该是： </p><pre><code>sudo nginx -t -c /etc/nginx/nginx.conf</code></pre>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何在 Ubuntu 14.04上面安装Linux, nginx, MySQL, PHP (LEMP)</title>
      <link href="/2016/04/24/14-04%E4%B8%8A%E9%9D%A2%E5%AE%89%E8%A3%85LEMP/"/>
      <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>LEMP是一套为动态网站和网页应用服务的软件包。这四个字母是一个缩写，包括了Linux操作系统(L)，Nginx网站服务器（N），后端的数据储存在Mysql中，以及用PHP对网站实行动态处理。</p><p>在这个教程中我们将解释如何在ubuntu 14.04 server 中 安装LEMP。</p><h2 id="预备条件"><a href="#预备条件" class="headerlink" title="预备条件"></a>预备条件</h2><p>在你完成这个教程之前，你应该在你的服务器或者本地机器上有一个普通的，非管理员的，但是带<code>sudo</code> 权限的的帐号。</p><p>如果你是在ubuntu server 上面安装LEMP，你应该先用上面的的帐号登陆你的服务器，然后就可以愉快的进行这个教程了。</p><p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li><a id="more"></a><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h2 id="1-安装Nginx-网站服务器"><a href="#1-安装Nginx-网站服务器" class="headerlink" title="1.安装Nginx 网站服务器"></a>1.安装Nginx 网站服务器</h2><p>为了给我们的浏览者可以展示我们的网站，我们即将使用一个高效率的现代化的网站服务器——Nginx。</p><p>所有我们在这个程序中会用到的软件都可以直接重Ubuntu 自带的默认封装库中找到，这就意味着我们可以直接使用<code>apt</code>包管理器去完成我们安装。</p><p>因为这是我们第一次使用<code>apt</code>来安装软件，我们首先应该先更新我们本地的包（package），然后我们再安装Nginx：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></table></figure></li></ul><p>在ubuntu 14.04中，Nginx在运行上面的安装命令的时候，已经配置好了。<br>你可以通过在浏览器中访问你的服务器的域名或者IP地址（本地为localhost）来验证你的Nginx是否已经开启并且在运行当中。    </p><p>如果你没有指向你的服务器的域名或者没有公网IP地址，你也可以通过下面的方法来验证你的Nginx是否正确运行。</p><p><br><br>在终端里面输入下面两行代码中的其中一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr show eth0 | grep inet | awk &apos;&#123; print $2; &#125;&apos; | sed &apos;s/\/.*$//&apos;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">111.111.111.111</span><br><span class="line">fe80::601:17ff:fe61:9801</span><br></pre></td></tr></table></figure><p><br><br>又或者你可以尝试使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://icanhazip.com</span><br></pre></td></tr></table></figure></p><p>121.8.210.44</p><p><br>在你的浏览器的url中输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server_domain_name_or_IP</span><br></pre></td></tr></table></figure></p><p>就可以看到Ngxin的欢迎页<br><img src="https://assets.digitalocean.com/articles/lemp_1404/nginx_default.png" alt="Alt text"></p><h2 id="2-安装MySql去管理网站的数据"><a href="#2-安装MySql去管理网站的数据" class="headerlink" title="2.安装MySql去管理网站的数据"></a>2.安装MySql去管理网站的数据</h2><p>现在我们已经有了一个网站的服务器，现在我们现在需要安装一个数据库管理系统——MySql，去储存和管理我们网站的数据<br><br></p><p>我们可以很容易地通过下面的命令安装<code></code>MySql：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure></p><p>在安装过程中你可能会被要求在你的<code>MySql</code>中设置一个管理员（root）密码。<br><br><br>那么现在<code>MySql</code>数据库已经安装完成了，但是他的配置并没有完成。<br><br><br>首先，我们地告诉MySql去生成目录结构，它需要储存数据库和信息，我们可以通过下面的命令实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql_install_db</span><br></pre></td></tr></table></figure></p><p>接下来,您将想要运行一个会提示你修改不安全的预设值的简单的安全的脚本，若要开启这个脚本，你只要输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql_secure_installation</span><br></pre></td></tr></table></figure></p><p>在安装过程中，你需要输入MySql系统管理员密码。<br><br></p><p>接下来，它会问你是否改变密码。如果你对目前的root的密码感到满意，直接输入“N”，不更改密码，如果需要更改密码，按下<code>ENTER</code>键，然后，系统将提示您删除一些测试用户和数据。你只需要根据提示按下<code>ENTER</code>键去消除不安全的默认设置就可以了。<br><br><br>一旦运行脚本结束,MySQL是准备好了！</p><h2 id="3-安装PHP"><a href="#3-安装PHP" class="headerlink" title="3.安装PHP"></a>3.安装PHP</h2><p>目前，我们已经有Nginx可以服务我们网站，有MySql去处理和储存数据，但是我们仍然需要一些东西去链接这两块，去构建一个动态的网站。PHP做得就是这个事情。<br><br><br>自从Nginx不像其他web服务器一样支持原生PHP后，我们需要安装<code>php5-fpm</code>来替代<code>fastCGI process manager</code>我们将告诉Nginx通过PHP请求这个软件进行处理。<br><br><br>我们除了会安装这个模块以外，我们还会顺带攫取一些允许<code>PHP</code>与我们的数据库后端通信的附加助手包。这个安装过程会引入必要的<code>PHP</code>核心文件。<br>使用下面的命令进行安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php5-fpm php5-mysql</span><br></pre></td></tr></table></figure></p><h3 id="配置PHP处理器"><a href="#配置PHP处理器" class="headerlink" title="配置PHP处理器"></a>配置PHP处理器</h3><p>刚刚我们已经成功安装了<code>PHP</code>组件，但是我们需要做一个小小的配置，来使到我们的PHP设置更加安全。</p><p>使用root权限打开主php5-fpm配置文件（使用了nano编辑器）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/php5/fpm/php.ini</span><br></pre></td></tr></table></figure></p><p>我们要在这个配置文件中找到<code>cgi.fix_pathinfo</code>，它时被用分号（;）注释掉的，默认值是“1”。<br>这是一个非常不安全的设置,因为它告诉PHP如果一个PHP文件不完全匹配，它将尝试执行它能找到的最近的文件，这将允许用户通过“精心准备”的PHP请求的方式让他们执行本来他们不能执行的文件。<br><br><br>我们即将通过去 掉；注释，并且把默认值设置为”0“的方式改变这两个条件。<br>就像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cgi.fix_pathinfo=0</span><br></pre></td></tr></table></figure></p><p><br><br>当你完成了这些配置的时候，保存并且退出文件。</p><p><br><br>现在我们只需要<strong>重新启动</strong>我们的PHP处理器就行了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service php5-fpm restart</span><br></pre></td></tr></table></figure></p><p>这将实现改变。<br>sudo service nginx restart</p><h2 id="4-配置Nginx使PHP能够正确运行"><a href="#4-配置Nginx使PHP能够正确运行" class="headerlink" title="4.配置Nginx使PHP能够正确运行"></a>4.配置Nginx使PHP能够正确运行</h2><p>现在,我们已经安装了所有必需的组件，现在我们唯一要配置的是告诉Nginx利用PHP去处理动态的内容。</p><p><br><br>我们将修改服务器消息块（server block）（这就像<code>Apache</code>上面的虚拟主机），打开默认Nginx服务器配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/nginx/sites-available/default</span><br></pre></td></tr></table></figure></p><p>现在，删除注释以后，Nginx默认服务器配置文件看起来是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    listen [::]:80 default_server ipv6only=on;</span><br><span class="line"></span><br><span class="line">    root /usr/share/nginx/html;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line"></span><br><span class="line">    server_name localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files $uri $uri/ =404;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们需要为适配我们的网站。对这个文件做出修改：</p><ul><li>首先，我们需要在<code>index</code>指令中增加一个<code>index.php</code>选项，来使到我们的PHP索引页可以在有请求的情况下被解析。</li><li>我们同样需要修改<code>server_name</code>这个指令，使到它能能够指向我们服务器的域名或者公网IP地址。</li><li>实际的配置文件中还包含了一些定义了错误处理例程的指令，但是他们被注释了，我们应该把我们需要的功能取消注释。</li><li>在实际PHP处理过程中，我们需要对一段的一部分取消注释。同时，我们还需要增加一个<code>try_files</code>避免Nginx发送一些错误的请求给PHP。</li></ul><p>修改了以后大概就像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    listen [::]:80 default_server ipv6only=on;</span><br><span class="line"></span><br><span class="line">    root /usr/share/nginx/html;</span><br><span class="line">    index index.php index.html index.htm;</span><br><span class="line"></span><br><span class="line">    server_name server_domain_name_or_IP;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files $uri $uri/ =404;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 404 /404.html;</span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        try_files $uri =404;</span><br><span class="line">        fastcgi_split_path_info ^(.+\.php)(/.+)$;</span><br><span class="line">        fastcgi_pass unix:/var/run/php5-fpm.sock;</span><br><span class="line">        fastcgi_index index.php;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">        include fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当你完成了上面的修改，你就可以保存然后关闭这个文件了。<br>然后<strong>重启</strong>Nginx使到这个文件生效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service nginx restart</span><br></pre></td></tr></table></figure></p><h2 id="5-创建一个PHP文件来测试配置"><a href="#5-创建一个PHP文件来测试配置" class="headerlink" title="5.创建一个PHP文件来测试配置"></a>5.创建一个PHP文件来测试配置</h2><p>你的LEMP环境理论上应该已经搭建好了，我们还应该测试以确保Nginx可以正确的处理<code>.php</code>文件。<br>我们可以在网站的根目录创建一个<code>PHP</code>文件来测试。在网站的根目录创建一个叫做<code>info.php</code>的文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /usr/share/nginx/html/info.php</span><br></pre></td></tr></table></figure></p><p>我们可以输入下面的内容到新文件中，这是有效的PHP代码，可以返回关于这个服务器的格式化的信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">phpinfo();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>当你完成了上面的修改，你就可以保存然后关闭这个文件了。<br><br><br>然后在浏览器中输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server_domain_name_or_IP/info.php</span><br></pre></td></tr></table></figure></p><p>你可以看到一个使用php来生成的网站，其中包含了您的服务器信息。<br><img src="https://assets.digitalocean.com/articles/lemp_1404/php_info.png" alt="enter image description here"></p><p>如果你看到一个页面,是这样的，你就已经成功配置<code>PHP</code>和<code>Nginx</code>了。<br>你测试结束后，最好删除刚刚创建的文件    <code>info.php</code>，因为上面会暴露你的服务器的一些敏感信息，使到别人很容易黑进来。如果你需要的话，也可以很快地创建回来。<br>现在,通过下面命令删除文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /usr/share/nginx/html/info.php</span><br></pre></td></tr></table></figure></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>你现在已经拥有LEMP环境在你的 Ubuntu 14.04 上面啦，这为你的网站应用带来了一个非常灵活的基础。去开发更有意思的东西吧！</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> PHP </tag>
            
            <tag> Linux </tag>
            
            <tag> Nginx </tag>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git常用命令</title>
      <link href="/2016/04/18/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <content type="html"><![CDATA[<p>##Git 是什么？</p><blockquote><h4 id="Git的官方定义："><a href="#Git的官方定义：" class="headerlink" title="Git的官方定义："></a>Git的官方定义：</h4><p>Git 是一个免费开源的分布式版本控制系统，被用于高速有效地处理大大小小项目中所有文件。</p></blockquote><p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><hr><p>#Git 常用的命令行</p><hr><p><code>说明</code>：&lt;必选&gt;  [可选]</p><h2 id="创建仓库-Create"><a href="#创建仓库-Create" class="headerlink" title="创建仓库 Create"></a><strong>创建仓库 <code>Create</code></strong></h2><ul><li><p>从已有的<code>文件</code></p><p>  cd ~/project/myproject<br>  git init<br>  git add</p></li></ul><ul><li><p>从已有的<code>仓库</code></p><pre><code>git clone ~/existing/repo ~/new/repo git clone you@host.org:dir/project.git</code></pre></li><li><p>为已有的本地数据文件创建远程仓库</p><p>  mkdir repo.git &amp; cd repo.git </p><p>  git init –bare[–shared=group]      </p></li></ul><h2 id="浏览-Browse"><a href="#浏览-Browse" class="headerlink" title="浏览 Browse"></a><strong>浏览 <code>Browse</code></strong></h2><ul><li><p>工作目录中所有发生变化的文件</p><p>git status</p></li><li><p>已经纳入版本管理的文件所发生的变化</p><p>git diff</p></li><li><p>在<code>ID1</code>和<code>ID2</code>之间发生的变化</p><p>git log</p></li><li><p>变更的历史</p><p>git log</p></li><li><p>查看带文件修改记录的变更历史 </p><p>git watchanged</p></li><li><p>谁在什么时间修改了文件中的什么内容 </p><p>git blame <file> </file></p></li><li><p>查看特定变更的<code>ID</code>的更新细节 </p><p>git show <id> </id></p></li><li><p>查看特定变更<code>ID</code>中的特定文件的变更细节 </p><p>git diff <id>:<file> </file></id></p></li><li><p>All 所有的本地分支 </p><p>git branch  //带有“×” 标记的是当前分支 </p></li><li><p>按模式搜索 </p><p>git grep <pattern> [PATH]</pattern></p></li></ul><h2 id="分支-Branch"><a href="#分支-Branch" class="headerlink" title="分支 Branch"></a><strong>分支 <code>Branch</code></strong></h2><ul><li><p>切换到分支 BRANCH </p><p>git checkout <branch> </branch></p></li><li><p>把分支<code>B1</code>合并到分支<code>B2</code> </p><p>git checkout <b2><br>git merge <b1> </b1></b2></p></li><li><p>在当前的<code>HEAD</code>分支上创建一个分支 </p><p>git branch <branch></branch></p></li><li><p>在其他的分支<code>BASE</code>上创建一个新分支 <code>NEW</code> </p><p>git checkout <new> <base></new></p></li><li><p>删除 </p><p> git branch -d <branch></branch></p></li></ul><h2 id="更新Update"><a href="#更新Update" class="headerlink" title="更新Update"></a><strong>更新<code>Update</code></strong></h2><ul><li><p>从远端 <code>origin</code> 中获取最新的变更记录 </p><p> git fetch //不会进行合并操作 </p></li><li><p>从远端 <code>origin</code> 中获取最新的变更 </p><p> git pull //获取变更之后会进行合并操作 </p></li><li><p>应用别处获得的补丁 </p><p>git am -3 patch.mbox<br>//如果发生冲突，解决之后运行下面的命令<br>git am –resolve </p><h2 id="发布Publish"><a href="#发布Publish" class="headerlink" title="发布Publish"></a><strong>发布<code>Publish</code></strong></h2></li><li><p>提交所有本地修改 </p><p>git commit -a </p></li><li><p>给他人准备一个补丁 </p><p>git format-patch origin</p></li><li><p>把变更发布到远端<code>origin</code> </p><p>git push [REMOTE] [BRANCH] </p></li><li><p>标记一个版本或者里程碑 </p><p>git tag &lt;VERSION_NAME&gt; </p><h2 id="恢复Revert"><a href="#恢复Revert" class="headerlink" title="恢复Revert"></a><strong>恢复<code>Revert</code></strong></h2></li><li><p>恢复到最后提交状态 </p><p>git checkout -f | git reset –hard</p><p>//注意：无法撤消硬重置 （hard reset）</p></li><li><p>撤消最后的提交 </p><p>git revert HEAD<br>  //会生成新的提交记录</p></li><li><p>撤消特定的提交 </p><p>git revert <id><br>  //会生成新的提交记录</id></p></li><li><p>修改特定的提交 </p><p>git commit -a –amend<br>  //在编辑了一个损坏的文件之后</p></li><li><p>签出文件的一个特定的版本<code>ID</code> </p><p>git checkout <id> <file></file></id></p><blockquote><p>To be  continue…</p></blockquote></li></ul>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我在广工大的这一年</title>
      <link href="/2015/08/18/%E6%88%91%E5%9C%A8%E5%B9%BF%E5%B7%A5%E5%A4%A7%E7%9A%84%E8%BF%99%E4%B8%80%E5%B9%B4/"/>
      <content type="html"><![CDATA[<blockquote><p> 听说20岁以后，时间会过得很快。</p></blockquote><p>  想想好像不久前才高中毕业，一下子就结束了自己的大一了。想起高中经历了很多新鲜有趣的事情，高三那年暑假都没有好好记录下来，就突发奇想，去尝试一下记录自己的大学生活，一年一年地记下来，希望自己的大学可以留下一点什么东西，而且觉得自己的大一生活，经历也还是挺丰富的，也希望思考一下这一年做过的事，思考一下自己未来的路怎么走。</p><p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h2 id="关于学习"><a href="#关于学习" class="headerlink" title="关于学习"></a>关于学习</h2><blockquote><p>开学 -&gt; 上课 -&gt; 复习 -&gt; 放假 -&gt; …….  -&gt; 实习 -&gt; 毕业设计  -&gt; 毕业<br><strong>难道大学就这样过去了吗？</strong>  </p></blockquote><p>作为一个大一的学生我也不好过多地去评价大学的教育，只是粗略地记录一下自己的学习情况。这一年来，真的除了上计算机的专业课程会很认真以外，其他课程基本上就是浑浑噩噩，基本学不到什么东西，这学期上过最认真的课就是<code>C语言程序设计</code>了。其原因有几个：</p><ul><li><p>①，我觉得很多没有意义的课程根本没有开设的需要，我不会听，这个不举例子。</p></li><li><p>②，这个问题比较重要，就是老师的教课水平，上部分老师的课程分明就是学不到东西的，因为上课就是念PPT，而且整版都是字字字字字字字，这就算了，还一副不在乎的样子，听这样的老师上课能学到东西吗？可以说是浪费时间，倒不如逃课，自己去自修室拿本经典的教材自学，况且计算机类的教材本来就不少。</p><p>   这里谈到逃课的问题，我顺便说两句，本人是支持逃课的，但是请继续往下看，你觉得学不到东西，或者那节课的老师根本给不了什么东西你，可以尽管逃课。但是，我希望你记住，逃课要去做一些有<code>意义的事情</code>，上大学以来，看到很多同学，就是早课不去上，在宿舍睡觉，又或者逃课打撸啊撸，看pian。如果你觉得那节课没用，你可以看看你自己想学的东西，不要浪费时间，如果那节课很重要，你可以自己去买经典的教材自学，不一定局限于学校的自编教材，甚至，更好的做法是是可以尝试去听其他的老师讲课，说不定其他的老师的教授方法你可以接受，但是无论如何，希望不要浪费时间，这是我自己的看法。</p></li><li><p>③，这个是关于学习目的的，上了大学一年，特别是高数课程，我听到老师说过最多的话，除了函数，就是这个题零几年的期末考试考过，这题又是什么时候考过，有没有想过，我们上课的意义是什么，我们还是高中生吗？我们需要真的只是考试中拿下一个高分吗？no，no，no， 我觉得我们需要的学习系统解决问题的方法，而不是去应付考试，老师应该提醒我们这个解决方法很重要，而不是提醒我们这个题哪年考试考过，告诉我也没用，好像现在考试结束了，谁还记得哪年考过，只是，我们记得有这样的一个解决方法，以前有老师说过，<code>学了忘了，剩下的才是教育</code>。大学不是技校，我们也不要狭隘地以为大学就是学门技术，我们要学习的是系统解决问题的方法，即使我们不懂该学科的相关知识，但是我们知道该怎么去学习。</p></li></ul><p>对了，还需要记录一下就是自己的上课时间的问题，基本上早课就是压哨到课室，这个坏习惯得改。<br>噢，还有，上大学才发现，原来上课可以一整排人一起玩手机，这场面，看看都觉得醉了。还是那句话，希望不要浪费时间。</p><h2 id="关于GPA"><a href="#关于GPA" class="headerlink" title="关于GPA"></a>关于GPA</h2><p>说起<strong>绩点</strong>这个事情，又是伤心事，每次都是开始有希望，但是很快又变成没希望，其实我觉绩点是证明一个人学习成绩的数据，别人看到你厉不厉害，很大程度上就是看绩点，但是我觉得评价一个人的能力绝对不是仅仅依靠绩点的，就像我这种过不会考试的人，绩点自然就是渣渣，但是，并不是说明我就是一无是处啊。但是我觉得绩点这个东西，考试之前还是刷一下比较好。毕竟，你也不想用人单位看到你的渣渣绩点……而且大学很多评价方法都是看绩点的，例如奖学金，保研，留学，绩点占据的份额都特别大。所以还是认真对待比较好。</p><h2 id="关于社团经历"><a href="#关于社团经历" class="headerlink" title="关于社团经历"></a>关于社团经历</h2><p>这学期本来加了两个部门的，一个是<code>社联网编部</code> ，<code>团委科技部</code> 其实两个部门都挺好的，主要是太忙，可是说，我第一个学期基本上就是社团忙忙忙然后就过去。 刚刚开学的时候真的<strong>觉得什么都好</strong>，什么都想尝试一下，什么都不想放弃，然后，就加入了两个部门，经常见就会有时间上面的冲突，请假又觉得非常不好意思，所以很多时候都是顶着上，第一学期功课真的落下了很多，特别是高数，基本没怎么学。第一学期最烦的一个事情就是想着怎么去分配自己的时间，经常会纠结到底该不该退掉一个部门，经过了很久的思想上面的折腾，最后，和几位部长也谈过人生，真的谈人生，两个部门的人都有，其中，网编部的正部是我和他谈得最多的，其实当时我还是不想退任何一个，因为我不想伤害他们，然后，科技部某一次会议就谈到了这个话题：“如果你们还有其他部门，忙不过来的可以申请退部，因为我们当时招多了人的。” 我当时就蒙了，最后，为了学业着想，我还是选择了退出科技部，这也是大一遗憾之一。不过当时陈师兄和我说过的话大概还记得<strong>“没有人敢说你的的决定是对的还是错的，如果你觉得是对的，你就要去坚持，加油”</strong>后来就专心投入到学习和社联的工作当中去了，没想到还是这么忙，社联的工作量实在是超乎我想象，一个大活动办起来，基本就是六七十套的桌椅这样子搬运，而且好做多事情，扫楼，各种各样的事情，每一次办完活动，就像大病一场，非常辛苦，而且，由于其他部门经常会很迟才给我们资料，所以，活动之前，我们经常会通宵做视频，慢慢地，几个活动下来，就不断有人退部了。其实，最大的不满还是出于搬桌椅，真心烦。</p><p>其实在部门你说学东西，也没学到什么东西，待人接物可以学到一点的，不过，主要是认识一群非常好的骂不走的朋友，还有5个非常关心我们的部长，部长们带着我们看清大学，其实挺感谢他们的，在大学，就像我们的大哥大姐一样，对我们照顾有加，真的<strong>谢谢</strong>！部门里面认识的朋友，估计就是大学甚至以后可以一起玩的人了。</p><p>还有一个事不能忘记，这学期还拍了一部微电影，四个人，这四个人，四个单身狗，现在已经是最好的朋友了，谢谢你们的陪伴，谢谢你们的不离不弃，虽然是单身狗，但是还是希望你们尽快找到自己的另一半的，希望还可以可以玩耍，哈哈。让我们一起走下去吧。</p><blockquote><p>世界这么大，我想去看看！</p></blockquote><p>最后，还是难免到了决定是否留任的问题了，其实很早我就决定了不留部的了，因为，我觉得<strong>世界这么大，我想去看看</strong>，我不想自己的大学生活就是这样像大一一样被限制在社联，我想寻求一条更加宽广的发展之路，我想，大二我应该为自己着想一下了，应该静下来想想自己往后的日子该怎么过了。 不料，正部长一句话就把我镇住了，虽然，我事先已经和他阐述过相关的观点，他也非常体谅我，我知道他真的是一个好部长，他说“<code>你留下来我会又开心有心痛</code>”，这是他之前所得，最后说的话是“<code>你是正部长的唯一人选。</code>”，看到部长的背影，心酸。经过了几个晚上不眠不休的思考，还有和某人的聊天，我最后还是慎重地决定不留，因为，我最后觉得，我现在的脚步已经走得相当慢了。我不希望在带上部门，这样无论对于我还是对于社团来说都是不好的，我希望我可以move faster！ 当然，另外一个考虑的因素是我希望留点时间给身边的人，不希望把自己榨干。希望，我可以继续走下去，谢谢所有支持我的人！</p><h2 id="关于工作室"><a href="#关于工作室" class="headerlink" title="关于工作室"></a>关于工作室</h2><blockquote><p>希望能和牛人一起进步，做一些改变世界的事。</p></blockquote><p>加入<strong>Vtmer工作室</strong>其实也是纯粹巧合吧，我觉得。哈哈，本来就喜欢编程的我，在第一个技术团队招新的时候就忍不住直接去笔试面试考核，然后就过了，其实我是喜欢编程，但是，我也没有想过我会加入到互联网的行业当中，然而， 还越来越喜欢~ </p><p>高中时候的我非常喜欢搞硬件，不过现在想起来，互联网好像也挺好的。</p><p>工作室最大的优点就是自由，最大的缺点也是过于自由。其实，工作室真的可以锻炼一个人的自学能力。而且工作室里面的人都很逗比，一起玩的时候非常开心。</p><p>而且我觉得工作室这些技术团队最主要的好处是可以让我们学习teamwork，当今社会，要想自己完成一个很大的project基本已经是不可能的事情了。这一年真的学到了好多，项目管理，协同合作，代码管理，谈需求，写文档等等……</p><p>目前在点亮的技能有：</p><pre><code>HTML　PHP  Mysql　ｃ　Laravel  niginx Vagrant　Linux  Vim</code></pre><p>  继续加油吧！</p><h2 id="关于梦想"><a href="#关于梦想" class="headerlink" title="关于梦想"></a>关于梦想</h2><blockquote><p>关于理想我从来没选择放弃<br>即使在灰头土脸的日子里<br>  ——《追梦赤子心》</p></blockquote><p>高二就确定下来的梦想到现在都没有改变，现在已经觉得自己在一步一步地接近自己的梦想，而且前进过程中也慢慢认清楚自己的路，知道自己想要的是什么，喜欢的东西是什么，现在只是觉得好玩，想做个好产品，希望自己可以坚持下去！</p><h2 id="几件需要记录的事"><a href="#几件需要记录的事" class="headerlink" title="几件需要记录的事"></a>几件需要记录的事</h2><ul><li>拍摄了微电影<a href="http://v.qq.com/boke/page/a/0/p/a0154iq2oxp.html" target="_blank" rel="noopener">《收到请回复》</a></li><li>去看哆啦A梦（这个必须记下来，大学最开心的一天）</li><li>加入了社联</li><li>加入了Vtmer Studio</li><li>想到再更新 </li></ul><h2 id="To-Sum-Up"><a href="#To-Sum-Up" class="headerlink" title="To Sum Up"></a>To Sum Up</h2><blockquote><p>大学，看起来只是一座建筑，却是那么多人带着梦想进来的地方。在这里，我们为自己的小事大笑、难过、骄傲、失落，成长的过程中，我们不免碰壁，伤痕累累。这些，都是成长的代价，也是成长的馈赠。不计代价爱你的家人也好，毫无保留站在你背后的朋友也好，易碎的爱情也好，教会我们用心去珍惜，用力去前进的，正是这些洒落在大学里的时光。      –《尼玛！这就是大学》                                                              </p></blockquote><p>这句话总结大一，最好不过。</p><p><strong>再见大一，你好大二。</strong></p>]]></content>
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
