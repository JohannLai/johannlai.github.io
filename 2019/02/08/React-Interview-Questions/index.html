<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>React 常见的面试题（在 React 里面，你可以知道也可以不知道的事, 但是你会发现他们确实很有用） | Johann Lai's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">React 常见的面试题（在 React 里面，你可以知道也可以不知道的事, 但是你会发现他们确实很有用）</h1><a id="logo" href="/.">Johann Lai's Blog</a><p class="description">Stay hungry，Stay foolish.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 文章</i></a><a href="/about/"><i class="fa fa-user"> 关于我</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">React 常见的面试题（在 React 里面，你可以知道也可以不知道的事, 但是你会发现他们确实很有用）</h1><div class="post-meta">Feb 8, 2019<span> | </span><span class="category"><a href="/categories/技术/">技术</a><a href="/categories/技术/翻译/">翻译</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>根据记录，问这些问题可能不是深入了解他们在使用 React 方面的经验的最佳方式。<br>之所以标题是《 React 常见的面试题》，其实只是想起一个比《在 React 里面，你可以知道也可以不知道的事, 但是你会发现他们确实很有用》要简单明了的标题而已。</p>
<p><img src="https://tylermcginnis.com/react-interview-questions/react-interview-questions.jpg" alt="React 常见的面试题"></p>
<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p>
<ul>
<li><a id="more"></a>
<the rest="" of="" contents="" |="" 余下全文="">


</the></li>
</ul>
<p>原文链接：<a href="https://tylermcginnis.com/react-interview-questions/" target="_blank" rel="noopener">React Interview Questions
</a></p>
<p>作者： Tyler.Google Developer Expert and a partner at React Training where we teach React online</p>
<p>翻译：<a href="http://johannlai.com" target="_blank" rel="noopener">Johann Lai</a></p>
<h2 id="当你调用-setState-的时候，发生了什么事？"><a href="#当你调用-setState-的时候，发生了什么事？" class="headerlink" title="当你调用 setState 的时候，发生了什么事？"></a>当你调用 <strong>setState</strong> 的时候，发生了什么事？</h2><p>当调用 <code>setState</code> 时，React会做的第一件事情是将传递给 <code>setState</code> 的对象合并到组件的当前状态。这将启动一个称为一致化处理（reconciliation）的过程。一致化处理（reconciliation）的最终目标是以最有效的方式，根据这个新的状态来更新UI。 为此，React将构建一个新的 <code>React</code> 元素树（您可以将其视为 UI 的对象表示）。<br>一旦有了这个树，为了弄清 UI 如何响应新的状态而改变，React 会将这个新树与上一个元素树相比较（<strong>diff</strong>）。   </p>
<p>（译注：一致化处理（reconciliation）可理解为 React 内部将虚拟 DOM 同步更新到真实 DOM 的过程，包括新旧虚拟 DOM 的比较及计算最小 DOM 操作）</p>
<p>通过这样， React 将会知道发生的确切变化，并且了解发生什么变化以后，只需在绝对必要的情况下进行更新，即可最小化 UI 的占用空间。</p>
<hr>
<h2 id="在-React-当中-Element-和-Component-有何区别？"><a href="#在-React-当中-Element-和-Component-有何区别？" class="headerlink" title="在 React 当中  Element 和  Component 有何区别？"></a>在 React 当中  Element 和  Component 有何区别？</h2><p>简单地说，一个 <strong>React  element</strong> 描述了你想在屏幕上看到什么。换个说法就是，一个 <strong>React  element</strong>  是一些 UI 的对象表示。</p>
<p>一个 <strong>React Component</strong> 是一个函数或一个类，它可以接受输入并返回一个 <strong>React  element</strong> （通常是通过 JSX ，它被转化成一个 createElement 调用）。</p>
<p>有关更多信息，请查看 <a href="https://tylermcginnis.com/react-elements-vs-react-components/" target="_blank" rel="noopener">React Elements vs React Components</a></p>
<hr>
<h2 id="什么时候在功能组件-Functional-Component-上使用类组件-Class-Component-？"><a href="#什么时候在功能组件-Functional-Component-上使用类组件-Class-Component-？" class="headerlink" title="什么时候在功能组件( Functional Component )上使用类组件( Class Component)？"></a>什么时候在功能组件( Functional Component )上使用类组件( Class Component)？</h2><p>如果您的组件具有状态( state )或生命周期方法，请使用 Class 组件。否则，使用功能组件。</p>
<hr>
<h2 id="什么是-React-的-refs-，为什么它们很重要？"><a href="#什么是-React-的-refs-，为什么它们很重要？" class="headerlink" title="什么是 React 的 refs ，为什么它们很重要？"></a>什么是 React 的 refs ，为什么它们很重要？</h2><p><strong>refs</strong> 就像是一个逃生舱口，允许您直接访问DOM元素或组件实例。为了使用它们，您可以向组件添加一个 <strong>ref</strong> 属性，该属性的值是一个回调函数，它将接收底层的 DOM 元素或组件的已挂接实例，作为其第一个参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnControlledForm</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleSubmit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Input Value: "</span>, <span class="keyword">this</span>.input.value)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">'text'</span></span><br><span class="line">          ref=&#123;(input) =&gt; <span class="keyword">this</span>.input = input&#125; /&gt;</span><br><span class="line">        &lt;button type=<span class="string">'submit'</span>&gt;Submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上注意到我们的输入字段有一个 <strong>ref</strong> 属性，其值是一个函数。该函数接收放在实例上实际的 DOM 元素 input，以便在 <em>handleSubmit</em> 函数内部访问它。经常被误解的是，您需要使用类组件才能使用<strong>ref</strong> ，但 <strong>ref</strong> 也可以通过利用 <code>JavaScript</code> 中的<strong>闭包</strong>与 功能组件( functional components )一起使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomForm</span> (<span class="params">&#123;handleSubmit&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> inputElement</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;() =&gt; handleSubmit(inputElement.value)&#125;&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">'text'</span></span><br><span class="line">        ref=&#123;(input) =&gt; inputElement = input&#125; /&gt;</span><br><span class="line">      &lt;button type=<span class="string">'submit'</span>&gt;Submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>form&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="React-中的-keys-是什么，为什么它们很重要？"><a href="#React-中的-keys-是什么，为什么它们很重要？" class="headerlink" title="React 中的 keys 是什么，为什么它们很重要？"></a>React 中的 <strong>keys</strong> 是什么，为什么它们很重要？</h2><p><strong>keys</strong> 是帮助 React 跟踪哪些项目已更改、添加或从列表中删除的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;<span class="keyword">this</span>.state.todoItems.map(<span class="function">(<span class="params">&#123;task, uid&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;li key=&#123;uid&#125;&gt;&#123;task&#125;&lt;/li&gt;</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>每个<strong>keys</strong> 在兄弟元素之间是独一无二的。我们已经谈过几次关于一致化处理（reconciliation）的过程，而且这个一致化处理过程（reconciliation）中的一部分正在执行一个新的元素树与最前一个的差异。<strong>keys</strong> 使处理列表时更加高效，因为 React 可以使用子元素上的 <strong>keys</strong> 快速知道元素是新的还是在比较树时才被移动的。</p>
<p>而且 <strong>keys</strong> 不仅使这个过程更有效率，而且没有<strong>keys</strong>，React 不知道哪个本地状态对应于移动中的哪个项目。所以当你 map 的时候，不要忽略了 <strong>keys</strong> 。</p>
<h2 id="看下面的代码-如果您在-下创建了一个-React-元素，的组件定义将如何？"><a href="#看下面的代码-如果您在-下创建了一个-React-元素，的组件定义将如何？" class="headerlink" title="看下面的代码: 如果您在  下创建了一个 React 元素，的组件定义将如何？"></a>看下面的代码: 如果您在 <twitter> 下创建了一个 React 元素，<twitter>的组件定义将如何？</twitter></twitter></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Twitter username=<span class="string">'tylermcginnis33'</span>&gt;</span><br><span class="line">  &#123;(user) =&gt; user === <span class="literal">null</span></span><br><span class="line">    ? &lt;Loading /&gt;</span><br><span class="line">    : &lt;Badge info=&#123;user&#125; /&gt;&#125;</span><br><span class="line">&lt;/Twitter&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, PropTypes &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> fetchUser <span class="keyword">from</span> <span class="string">'twitter'</span></span><br><span class="line"><span class="comment">// fetchUser接收用户名返回 promise</span></span><br><span class="line"><span class="comment">// 当得到 用户的数据的时候 ，返回resolve 状态</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在这里写下你的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你不熟悉渲染回调模式（render callback pattern），这将看起来有点奇怪。在这种模式中，一个组件接收一个函数作为它的 child。注意上面包含在 <twitter>标签内的内容。<em>Twitter</em> 组件的 child 是一个函数，而不是你曾经习以为常的一个组件。 这意味着在实现 <em>Twitter</em> 组件时，我们需要将 <em>props.children</em> 作为一个函数来处理。 </twitter></p>
<p>以下是我的答案。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, PropTypes &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> fetchUser <span class="keyword">from</span> <span class="string">'twitter'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    user: <span class="literal">null</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    username: PropTypes.string.isRequired,</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    fetchUser(<span class="keyword">this</span>.props.username)</span><br><span class="line">      .then(<span class="function">(<span class="params">user</span>) =&gt;</span> <span class="keyword">this</span>.setState(&#123;user&#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children(<span class="keyword">this</span>.state.user)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>值得注意的是</strong>，正如我上面提到的，我通过调用它并传递给 user 来把 props.children 处理为一个函数。</p>
<p>这种模式的好处是我们已经将我们的父组件与我们的子组件分离了。父组件管理状态，父组件的消费者可以决定以何种方式将从父级接收的参数应用于他们的 UI。</p>
<p>为了演示这一点，我们假设在另一个文件中，我们要渲染一个 <em>Profile</em> 而不是一个 <em>Badge,</em>，因为我们使用渲染回调模式，所以我们可以轻松地交换 UI ，而不用改变我们对父（Twitter）组件的实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Twitter username=<span class="string">'tylermcginnis33'</span>&gt;</span><br><span class="line">  &#123;(user) =&gt; user === <span class="literal">null</span></span><br><span class="line">    ? &lt;Loading /&gt;</span><br><span class="line">    : &lt;Profile info=&#123;user&#125; /&gt;&#125;</span><br><span class="line">&lt;/Twitter&gt;</span><br></pre></td></tr></table></figure>
<h2 id="受控组件-controlled-component-与不受控制的组件-uncontrolled-component-有什么区别？"><a href="#受控组件-controlled-component-与不受控制的组件-uncontrolled-component-有什么区别？" class="headerlink" title="受控组件( controlled component )与不受控制的组件( uncontrolled component )有什么区别？"></a>受控组件( controlled component )与不受控制的组件( uncontrolled component )有什么区别？</h2><p>React 的很大一部分是这样的想法，即组件负责控制和管理自己的状态。</p>
<p>当我们将 native HTML 表单元素（ input, select, textarea 等）投入到组合中时会发生什么？我们是否应该使用 React 作为“单一的真理来源”，就像我们习惯使用React一样？ 或者我们是否允许表单数据存在 DOM 中，就像我们习惯使用HTML表单元素一样？ 这两个问题是受控（controlled） VS 不受控制（uncontrolled）组件的核心。</p>
<p><strong>受控</strong>组件是React控制的组件，也是表单数据的唯一真理来源。</p>
<p>如下所示，<em>username</em> 不存在于 DOM 中，而是以我们的组件状态存在。每当我们想要更新 <em>username</em> 时，我们就像以前一样调用setState。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ControlledForm</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    username: <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">  updateUsername = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      username: e.target.value,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  handleSubmit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">'text'</span></span><br><span class="line">          value=&#123;<span class="keyword">this</span>.state.username&#125;</span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.updateUsername&#125; /&gt;</span><br><span class="line">        &lt;button type=<span class="string">'submit'</span>&gt;Submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不受控制( uncontrolled component )的组件是您的表单数据由 DOM 处理，而不是您的 React 组件。</p>
<p>我们使用 <strong>refs</strong> 来完成这个。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnControlledForm</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleSubmit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Input Value: "</span>, <span class="keyword">this</span>.input.value)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">'text'</span></span><br><span class="line">          ref=&#123;(input) =&gt; <span class="keyword">this</span>.input = input&#125; /&gt;</span><br><span class="line">        &lt;button type=<span class="string">'submit'</span>&gt;Submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然不受控制的组件通常更容易实现，因为您只需使用引用从DOM获取值，但是通常建议您通过不受控制的组件来支持受控组件。</p>
<p>主要原因是受控组件<strong>支持即时字段验证</strong>，允许您有条件地禁用/启用按钮，强制输入格式，并且更多的是 『the React way』。</p>
<h2 id="在哪个生命周期事件中你会发出-AJAX-请求，为什么？"><a href="#在哪个生命周期事件中你会发出-AJAX-请求，为什么？" class="headerlink" title="在哪个生命周期事件中你会发出 AJAX 请求，为什么？"></a>在哪个生命周期事件中你会发出 AJAX 请求，为什么？</h2><p>AJAX 请求应该在 <code>componentDidMount</code> 生命周期事件中。 有几个原因:</p>
<ul>
<li><p>Fiber，是下一次实施React的和解算法，将有能力根据需要启动和停止渲染，以获得性能优势。其中一个取舍之一是 <code>componentWillMount</code>，而在其他的生命周期事件中出发 AJAX 请求，将是具有 “非确定性的”。 这意味着 React 可以在需要时感觉到不同的时间开始调用 componentWillMount。这显然是AJAX请求的不好方式。</p>
</li>
<li><p>您不能保证在组件挂载之前，AJAX请求已经 resolve。如果这样做，那意味着你会尝试在一个未挂载的组件上设置 SetState，这不仅不会起作用，反而会对你大喊大叫。 在 <code>componentDidMount</code> 中执行 AJAX 将保证至少有一个要更新的组件。</p>
</li>
</ul>
<h2 id="shouldComponentUpdate-应该做什么，为什么它很重要？"><a href="#shouldComponentUpdate-应该做什么，为什么它很重要？" class="headerlink" title="shouldComponentUpdate 应该做什么，为什么它很重要？"></a>shouldComponentUpdate 应该做什么，为什么它很重要？</h2><p>上面我们讨论了 reconciliation ，什么是 React 在 setState 被调用时所做的。在生命周期方法 shouldComponentUpdate 中，允许我们选择退出某些组件（和他们的子组件）的 reconciliation  过程。</p>
<p>我们为什么要这样做？</p>
<p>如上所述，“一致化处理（ reconciliation ）的最终目标是以最有效的方式，根据新的状态更新用户界面”。如果我们知道我们的用户界面（UI）的某一部分不会改变，那么没有理由让 React 很麻烦地试图去弄清楚它是否应该渲染。通过从 shouldComponentUpdate 返回 false，React 将假定当前组件及其所有子组件将保持与当前组件相同。</p>
<h2 id="您如何告诉React-构建（build）生产模式，该做什么？"><a href="#您如何告诉React-构建（build）生产模式，该做什么？" class="headerlink" title="您如何告诉React 构建（build）生产模式，该做什么？"></a>您如何告诉React 构建（build）生产模式，该做什么？</h2><p>通常，您将使用Webpack的 <em>DefinePlugin</em> 方法将 <strong>NODE_ENV</strong> 设置为 production。这将剥离像 propType 验证和额外的警告。除此之外，还有一个好主意，可以减少你的代码，因为React使用 Uglify 的 dead-code 来消除开发代码和注释，这将大大减少你的包的大小。</p>
<h2 id="为什么要使用-React-Children-map（props-children，（）-gt-）-而不是-props-children-map（（）-gt-）"><a href="#为什么要使用-React-Children-map（props-children，（）-gt-）-而不是-props-children-map（（）-gt-）" class="headerlink" title="为什么要使用 React.Children.map（props.children，（）=&gt;） 而不是 props.children.map（（）=&gt;）"></a>为什么要使用 React.Children.map（props.children，（）=&gt;） 而不是 props.children.map（（）=&gt;）</h2><p>因为不能保证props.children将是一个数组。 </p>
<p>以此代码为例，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Parent&gt;</span><br><span class="line">  &lt;h1&gt;Welcome.&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Parent&gt;</span><br></pre></td></tr></table></figure></p>
<p>在父组件内部，如果我们尝试使用 props.children.map 映射孩子，则会抛出错误，因为 props.children 是一个对象，而不是一个数组。</p>
<p>如果有多个子元素，React 只会使props.children成为一个数组。就像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Parent&gt;</span><br><span class="line">  &lt;h1&gt;Welcome.&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  &lt;h2&gt;props.children will now be an array&lt;/</span>h2&gt;</span><br><span class="line">&lt;<span class="regexp">/Parent&gt;</span></span><br></pre></td></tr></table></figure>
<p>这就是为什么你喜欢 <code>React.Children.map</code>，因为它的实现考虑到 <code>props.children</code> 可能是一个数组或一个对象。</p>
<h2 id="描述事件在React中的处理方式。"><a href="#描述事件在React中的处理方式。" class="headerlink" title="描述事件在React中的处理方式。"></a>描述事件在React中的处理方式。</h2><p>为了解决跨浏览器兼容性问题，您的 React 中的事件处理程序将传递<code>SyntheticEvent</code> 的实例，它是 React 的浏览器本机事件的跨浏览器包装器。</p>
<p>这些 <code>SyntheticEvent</code> 与您习惯的原生事件具有相同的接口，除了它们在所有浏览器中都兼容。有趣的是，React 实际上并没有将事件附加到子节点本身。React 将使用单个事件监听器监听顶层的所有事件。这对于性能是有好处的，这也意味着在更新DOM时，React 不需要担心跟踪事件监听器。</p>
<h2 id="createElement-和-cloneElement-有什么区别？"><a href="#createElement-和-cloneElement-有什么区别？" class="headerlink" title="createElement 和 cloneElement 有什么区别？"></a>createElement 和 cloneElement 有什么区别？</h2><p>createElement 是 JSX 被转载到的，是 React 用来创建 React Elements 的内容(一些 UI 的对象表示)cloneElement用于克隆元素并传递新的 props。他们钉住了这两个🙂的命名。</p>
<h2 id="可以选择性地传递给-setState-的第二个参数是什么，它的目的是什么？"><a href="#可以选择性地传递给-setState-的第二个参数是什么，它的目的是什么？" class="headerlink" title="可以选择性地传递给 setState 的第二个参数是什么，它的目的是什么？"></a>可以选择性地传递给 setState 的第二个参数是什么，它的目的是什么？</h2><p>一个回调函数，当setState结束并<code>re-rendered</code>该组件时将被调用。一些没有说出来的东西是 setState 是<strong>异步</strong>的，这就是为什么它需要一个第二个回调函数。通常最好使用另一个生命周期方法，而不是依赖这个回调函数，但是很高兴知道它存在。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'tylermcginnis33'</span> &#125;,</span><br><span class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'setState has finished and the component has re-rendered.'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="这段代码有什么问题？"><a href="#这段代码有什么问题？" class="headerlink" title="这段代码有什么问题？"></a>这段代码有什么问题？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.setState((prevState, props) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    streak: prevState.streak + props.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>没毛病。但是这种写法很少被使用，并不是众所周知的，就是你也可以传递一个函数给setState，它接收到先前的状态和道具并返回一个新的状态，正如我们在上面所做的那样。它不仅没有什么问题，而且如果您根据以前的状态（state）设置状态，推荐使用这种写法。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://yoursite.com/2019/02/08/React-Interview-Questions/" data-id="cjrvu4llr0008o5vmdb7sdzwo" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACJElEQVR42u3a0W6DMAwF0P7/T7PXThvU126nkZw8IUYhh0kmtvN4lMfxNJ7PnB2fnXk+f/bXn9e8bWBgYNyWcVyO3kSv7zM5f0rFwMDYgHEWwXrHlcmlz3oxZwwMDIy3kq6fjoGBgTFh9NLL+q8qoRkDA2NnRpp8VkLqP83FMTAwbshIg+ZfHn+kv4GBgXErxhGOynItLaX12gzffoWBgbE0Y9LCrCeiaSmtdzcMDIxVGb1tXr2C2rtaAr/MCgMDYxtGGubSVDPdalZvi2JgYKzNmE+6HkYrV/ZanhgYGDsw0jCablpN25D1ez4mXwMMDIxbMdJFWyU016c7aTlgYGDsyfhEWlufaFrse9HfwMDAWIJR34RaiWy9Ulr9WS/+DxgYGEsz0nJYGi7TFDd9fRgYGDswrkNkGlLr19cT5uC7gYGBsRyjl2SmhbB0OywGBgZG2sJMy/cTQPpqMDAw9mSkgW+yLaMHLm25wMDAWI5xnTrON170ktj4tWJgYGzAqG+8SAN0imkuLjEwMLZhTIJgZdk3X27GO0cwMDCWYNSXfb3W46SsFhf+MDAwlmMc4eiluCkj3SiGgYGxNiNdhNUXgvUHp2EdAwNjT0YvyKabM9LEOA64GBgYGzAqoTNtZ/bK/XGJDQMDA6PF6DVBJ8U4DAwMjHT52CvMjVqbGBgYGzB6SWzlpfSS0piKgYGxNCMNyvWQWomK9c/AJPXFwMC4LeMLGeqYTmb1OPcAAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/React/">React</a></div><div class="post-nav"><a class="pre" href="/2019/02/08/mysql-slow-query-log/">MySQL优化笔记----慢查询日志</a><a class="next" href="/2019/02/08/RegExp/">同学你该复习正则表达式了</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  owner: 'johannlai## Your GitHub ID, e.g. username',
  repo: 'johannlai.github.io## The repository to store your comments, make sure you're the repo's owner, e.g. imsun.github.io',
  oauth: {
    client_id: '74c460b19b433fc48e51',
    client_secret: 'b9bc48aee0871c1e515c4cc3e6f3c78ff0ba7e2e',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/分享/">分享</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/分享/笔记/">笔记</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/debug/">debug</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/分享/">分享</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/分享/笔记/">笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/分享/笔记/MySQL/">MySQL</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/分享/翻译/">翻译</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/前端/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/教程/">教程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/翻译/">翻译</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/资源/">资源</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/日记/">日记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/技术/" style="font-size: 15px;">技术</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/MySql/" style="font-size: 15px;">MySql</a> <a href="/tags/jQuery/" style="font-size: 15px;">jQuery</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/正则表达式/" style="font-size: 15px;">正则表达式</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/debug/" style="font-size: 15px;">debug</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/居中/" style="font-size: 15px;">居中</a> <a href="/tags/PHP/" style="font-size: 15px;">PHP</a> <a href="/tags/locahost/" style="font-size: 15px;">locahost</a> <a href="/tags/Django/" style="font-size: 15px;">Django</a> <a href="/tags/laravel/" style="font-size: 15px;">laravel</a> <a href="/tags/Ajax/" style="font-size: 15px;">Ajax</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/DOM/" style="font-size: 15px;">DOM</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/网络安全/" style="font-size: 15px;">网络安全</a> <a href="/tags/服务器/" style="font-size: 15px;">服务器</a> <a href="/tags/tmux/" style="font-size: 15px;">tmux</a> <a href="/tags/screen/" style="font-size: 15px;">screen</a> <a href="/tags/学校/" style="font-size: 15px;">学校</a> <a href="/tags/学习/" style="font-size: 15px;">学习</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/02/08/localhost/">localhost----从坑谈起</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/08/mysql-slow-query-log/">MySQL优化笔记----慢查询日志</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/08/React-Interview-Questions/">React 常见的面试题（在 React 里面，你可以知道也可以不知道的事, 但是你会发现他们确实很有用）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/08/RegExp/">同学你该复习正则表达式了</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/08/ajax/">MySQL远程连接ERROR 2003 (HY000):Can't connect to MySQL server on'XXXXX'(111) 的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/08/css-center/">CSS学习笔记----水平居中、垂直居中、水平垂直居中方法总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/08/ssh-broken/">ssh连接linux服务器不断开方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/08/safe/">Web安全</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/08/React Lifecycle Methods/">React 的生命周期的使用场景</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/08/Observer/">JQuery中的设计模式 ——Observer (观察者)模式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://zhangxiang958.github.io" title="Shawn's blog" target="_blank">Shawn's blog</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Johann Lai's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = '//hm.baidu.com/hm.js?' + '683f84f5e60a117252caaf135802f17f## Your Baidu Analytics tracking id, e.g. 8006843039519956000';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>